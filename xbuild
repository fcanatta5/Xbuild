#!/bin/sh

set -eu

###############################################################################
# Configuration (may be overridden by config file or env)
###############################################################################

XBUILD_VERSION=0.0

: "${XBUILD_ROOT:=$PWD}"
: "${XBUILD_WORK:=$XBUILD_ROOT/work}"
: "${XBUILD_SYSROOT:=$XBUILD_ROOT/sysroot}"
: "${XBUILD_DB:=$XBUILD_ROOT/db}"
: "${XBUILD_LOCKDIR:=$XBUILD_ROOT/.xbuild.lock}"

: "${XBUILD_INSTALL_MODE:=host}"   # host | sysroot
: "${XBUILD_JOBS:=1}"
: "${XBUILD_STRIP_SUID:=1}"         # 1 = strip setuid/setgid
: "${XBUILD_STRICT_SYSROOT:=1}"     # enforce sysroot isolation

umask 022

###############################################################################
# Utilities
###############################################################################

die() { printf 'xbuild: %s
' "$*" >&2; exit 1; }
msg() { printf '==> %s
' "$*" >&2; }

need() { command -v "$1" >/dev/null 2>&1 || die "missing required tool: $1"; }

mkdirp() { [ -d "$1" ] || mkdir -p "$1"; }

###############################################################################
# Locking (robust)
###############################################################################

lock() {
    mkdirp "$XBUILD_LOCKDIR"
    if [ -f "$XBUILD_LOCKDIR/meta" ]; then
        read -r pid ts host <"$XBUILD_LOCKDIR/meta" || true
        if [ -n "${pid:-}" ] && kill -0 "$pid" 2>/dev/null; then
            die "another xbuild instance is running (pid $pid)"
        fi
    fi
    printf '%s %s %s
' "$$" "$(date +%s)" "$(hostname 2>/dev/null || echo unknown)"         >"$XBUILD_LOCKDIR/meta"
}

unlock() { rm -rf "$XBUILD_LOCKDIR"; }
trap unlock EXIT INT TERM

###############################################################################
# Archive handling (hardened)
###############################################################################

validate_paths() {
    awk '
        BEGIN{bad=0}
        {
            if ($0 ~ /^\//) bad=1
            if ($0 ~ /\.\./) bad=1
        }
        END{exit bad}
    '
}

extract_tar() {
    arc=$1 out=$2
    mkdirp "$out"
    tar -tf "$arc" | validate_paths || die "unsafe paths in tar archive"
    tar --no-same-owner --no-same-permissions -xf "$arc" -C "$out"
}

extract_zip() {
    arc=$1 out=$2
    mkdirp "$out"
    unzip -Z1 "$arc" | validate_paths || die "unsafe paths in zip archive"
    unzip -oq "$arc" -d "$out"
}

extract() {
    arc=$1 out=$2
    case "$arc" in
        *.tar|*.tar.gz|*.tgz|*.tar.bz2|*.tar.xz|*.tar.zst)
            extract_tar "$arc" "$out" ;;
        *.zip)
            extract_zip "$arc" "$out" ;;
        *)
            die "unknown archive format: $arc" ;;
    esac
}

###############################################################################
# Database (refcounted ownership)
###############################################################################

pkg_db() { printf '%s/%s
' "$XBUILD_DB" "$1"; }

db_init_pkg() {
    p=$1
    mkdirp "$(pkg_db "$p")"
    : >"$(pkg_db "$p")/files"
}

db_add_file() {
    p=$1 f=$2
    printf '%s
' "$f" >>"$(pkg_db "$p")/files"
    mkdirp "$XBUILD_DB/.owners"
    printf '%s
' "$p" >>"$XBUILD_DB/.owners/$f"
}

db_remove_pkg() {
    p=$1
    [ -d "$(pkg_db "$p")" ] || die "package not installed: $p"
    while IFS= read -r f; do
        owners="$XBUILD_DB/.owners/$f"
        if [ -f "$owners" ]; then
            grep -v "^$p\$" "$owners" >"$owners.tmp" || true
            mv "$owners.tmp" "$owners"
            if [ ! -s "$owners" ]; then
                rm -f "$owners"
                rm -f "$f"
            fi
        fi
    done <"$(pkg_db "$p")/files"
    rm -rf "$(pkg_db "$p")"
}

###############################################################################
# Merge install (collision safe)
###############################################################################

merge_tree() {
    pkg=$1 staged=$2 root=$3

    find "$staged" -type f -o -type l | while IFS= read -r src; do
        rel=${src#$staged/}
        dst=$root/$rel

        if [ -e "$dst" ]; then
            owners="$XBUILD_DB/.owners/$dst"
            if [ -f "$owners" ]; then
                :
            else
                die "file collision: $dst already exists"
            fi
        fi

        mkdirp "$(dirname "$dst")"
        cp -a "$src" "$dst"

        if [ "$XBUILD_STRIP_SUID" = "1" ]; then
            chmod ug-s "$dst" 2>/dev/null || true
        fi

        db_add_file "$pkg" "$dst"
    done
}

###############################################################################
# Build
###############################################################################

build_pkg() {
    recipe=$1
    . "$recipe" || die "failed to load recipe"

    : "${PKGNAME:?missing PKGNAME}"
    : "${VERSION:?missing VERSION}"
    : "${SOURCE:?missing SOURCE}"

    work="$XBUILD_WORK/$PKGNAME-$VERSION"
    srcdir="$work/src"
    builddir="$work/build"
    staged="$work/stage"

    rm -rf "$work"
    mkdirp "$srcdir" "$builddir" "$staged"

    msg "extracting $PKGNAME"
    extract "$SOURCE" "$srcdir"

    msg "building $PKGNAME"
    (
        cd "$builddir"
        if [ "$XBUILD_INSTALL_MODE" = "sysroot" ]; then
            export DESTDIR="$staged"
            export PKG_CONFIG_SYSROOT_DIR="$XBUILD_SYSROOT"
            export PKG_CONFIG_LIBDIR="$XBUILD_SYSROOT/lib/pkgconfig"
        else
            export DESTDIR="$staged"
        fi
        build
        install
    )

    msg "installing $PKGNAME"
    db_init_pkg "$PKGNAME"
    merge_tree "$PKGNAME" "$staged" "/"

    msg "$PKGNAME installed"
}

###############################################################################
# Main
###############################################################################

need tar
need awk
need grep
need cp
need rm
need find

lock

case "${1:-}" in
    build)
        [ $# -eq 2 ] || die "usage: xbuild build recipe"
        build_pkg "$2"
        ;;
    remove)
        [ $# -eq 2 ] || die "usage: xbuild remove pkg"
        db_remove_pkg "$2"
        ;;
    *)
        die "usage: xbuild {build|remove}"
        ;;
esac
