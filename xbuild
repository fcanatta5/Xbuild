#!/bin/sh
# License: public domain / do-what-you-want.

set -eu

###############################################################################
# Utilities
###############################################################################
die() { printf '%s\n' "xbuild: $*" >&2; exit 1; }
msg() { printf '%s\n' "==> $*" >&2; }

need_cmd() { command -v "$1" >/dev/null 2>&1 || die "missing required command: $1"; }

# portable mkdir -p
mkd() { [ -d "$1" ] || mkdir -p "$1"; }

# sha256 verifier (supports sha256sum or shasum -a 256)
sha256_file() {
    if command -v sha256sum >/dev/null 2>&1; then
        sha256sum "$1" | awk '{print $1}'
    elif command -v shasum >/dev/null 2>&1; then
        shasum -a 256 "$1" | awk '{print $1}'
    else
        die "need sha256sum or shasum"
    fi
}

download() {
    # download URL to DEST (resume if possible)
    url=$1 dest=$2
    if command -v curl >/dev/null 2>&1; then
        curl -L --fail --retry 3 -C - -o "$dest".part "$url" || die "download failed: $url"
        mv "$dest".part "$dest"
    elif command -v wget >/dev/null 2>&1; then
        wget -O "$dest".part "$url" || die "download failed: $url"
        mv "$dest".part "$dest"
    else
        die "need curl or wget"
    fi
}

extract() {
    # extract archive $1 into dir $2
    arc=$1 out=$2
    mkd "$out"
    case "$arc" in
        *.tar.gz|*.tgz)  tar -xzf "$arc" -C "$out" ;;
        *.tar.xz)        tar -xJf "$arc" -C "$out" ;;
        *.tar.bz2)       tar -xjf "$arc" -C "$out" ;;
        *.tar.zst)       tar --zstd -xf "$arc" -C "$out" ;;
        *.tar)           tar -xf "$arc" -C "$out" ;;
        *.zip)           need_cmd unzip; unzip -q "$arc" -d "$out" ;;
        *) die "unknown archive format: $arc" ;;
    esac
}

# run command with logging
run_logged() {
    logfile=$1; shift
    # shellcheck disable=SC2068
    "$@" >>"$logfile" 2>&1
}

###############################################################################
# Configuration
###############################################################################
XBUILD_ROOT=${XBUILD_ROOT:-"$PWD/root"}
CONF="$XBUILD_ROOT/config"

# defaults (overridable in config)
XBUILD_DIST="$XBUILD_ROOT/distfiles"
XBUILD_BUILD="$XBUILD_ROOT/build"
XBUILD_PKGS="$XBUILD_ROOT/pkgs"
XBUILD_DB="$XBUILD_ROOT/db"
XBUILD_LOGS="$XBUILD_ROOT/logs"

# install prefix / sysroot (for from-scratch systems you usually want /usr inside a sysroot)
XBUILD_SYSROOT=${XBUILD_SYSROOT:-""}         # e.g. /mnt/sysroot (empty means real /)
XBUILD_PREFIX=${XBUILD_PREFIX:-/usr}         # where packages install (within sysroot)
XBUILD_MAKEJ=${XBUILD_MAKEJ:-1}

# toolchain env (native defaults)
XBUILD_CC=${XBUILD_CC:-cc}
XBUILD_CXX=${XBUILD_CXX:-c++}
XBUILD_AR=${XBUILD_AR:-ar}
XBUILD_RANLIB=${XBUILD_RANLIB:-ranlib}
XBUILD_STRIP=${XBUILD_STRIP:-strip}
XBUILD_CFLAGS=${XBUILD_CFLAGS:-"-O2 -pipe"}
XBUILD_CXXFLAGS=${XBUILD_CXXFLAGS:-"$XBUILD_CFLAGS"}
XBUILD_LDFLAGS=${XBUILD_LDFLAGS:-""}
XBUILD_PKG_CONFIG=${XBUILD_PKG_CONFIG:-pkg-config}

load_config() {
    if [ -f "$CONF" ]; then
        # shellcheck disable=SC1090
        . "$CONF"
    fi
    # re-apply dirs in case config changed root variables
    XBUILD_DIST=${XBUILD_DIST:-"$XBUILD_ROOT/distfiles"}
    XBUILD_BUILD=${XBUILD_BUILD:-"$XBUILD_ROOT/build"}
    XBUILD_PKGS=${XBUILD_PKGS:-"$XBUILD_ROOT/pkgs"}
    XBUILD_DB=${XBUILD_DB:-"$XBUILD_ROOT/db"}
    XBUILD_LOGS=${XBUILD_LOGS:-"$XBUILD_ROOT/logs"}
}

init_layout() {
    mkd "$XBUILD_ROOT"
    mkd "$XBUILD_DIST" "$XBUILD_BUILD" "$XBUILD_PKGS" "$XBUILD_DB" "$XBUILD_LOGS"
    if [ ! -f "$CONF" ]; then
        cat >"$CONF" <<EOF
# xbuild config (POSIX sh)
# Root directories:
XBUILD_ROOT="$XBUILD_ROOT"
XBUILD_DIST="$XBUILD_DIST"
XBUILD_BUILD="$XBUILD_BUILD"
XBUILD_PKGS="$XBUILD_PKGS"
XBUILD_DB="$XBUILD_DB"
XBUILD_LOGS="$XBUILD_LOGS"

# Install target:
# If building a fresh system under a mount point, set XBUILD_SYSROOT="/mnt/sysroot"
XBUILD_SYSROOT="${XBUILD_SYSROOT}"
XBUILD_PREFIX="${XBUILD_PREFIX}"

# Parallel builds:
XBUILD_MAKEJ="${XBUILD_MAKEJ}"

# Toolchain:
XBUILD_CC="${XBUILD_CC}"
XBUILD_CXX="${XBUILD_CXX}"
XBUILD_AR="${XBUILD_AR}"
XBUILD_RANLIB="${XBUILD_RANLIB}"
XBUILD_STRIP="${XBUILD_STRIP}"

# Flags:
XBUILD_CFLAGS='${XBUILD_CFLAGS}'
XBUILD_CXXFLAGS='${XBUILD_CXXFLAGS}'
XBUILD_LDFLAGS='${XBUILD_LDFLAGS}'
XBUILD_PKG_CONFIG='${XBUILD_PKG_CONFIG}'
EOF
        msg "created config at $CONF"
    else
        msg "config already exists at $CONF"
    fi
}

###############################################################################
# Recipe handling
###############################################################################
pkg_dir() { printf '%s\n' "$XBUILD_PKGS/$1"; }
pkg_recipe() { printf '%s\n' "$(pkg_dir "$1")/recipe"; }

pkg_assert_exists() {
    [ -d "$(pkg_dir "$1")" ] || die "package not found: $1"
    [ -f "$(pkg_recipe "$1")" ] || die "missing recipe file: $(pkg_recipe "$1")"
}

db_prefix() {
    # database dir entry for a package version
    # expects PKGNAME, PKGVER set
    printf '%s\n' "$XBUILD_DB/${PKGNAME}-${PKGVER}"
}

# load recipe into current shell:
# Recipe must set: PKGNAME, PKGVER, SRCURL, SRCSHA256
# Optional:
#   SRCTARBALL (filename override)
#   BUILD_SYSTEM: autotools|cmake|meson|make|custom
#   DEPENDS (space-separated)
#   PATCHES (space-separated patch filenames under pkg dir)
# Hooks (functions):
#   pre_fetch, post_fetch, pre_extract, post_extract
#   pre_build, do_build, post_build
#   pre_install, do_install, post_install
#   do_remove (optional custom removal)
load_recipe() {
    pkg=$1
    pkg_assert_exists "$pkg"
    # reset potentially stale vars
    PKGNAME= PKGVER= SRCURL= SRCSHA256= SRCTARBALL=
    BUILD_SYSTEM= DEPENDS= PATCHES=
    # unset hooks if present (POSIX: can't unset functions portably; override with no-op)
    pre_fetch() { :; }; post_fetch() { :; }
    pre_extract() { :; }; post_extract() { :; }
    pre_build() { :; }; do_build() { :; }; post_build() { :; }
    pre_install() { :; }; do_install() { :; }; post_install() { :; }
    do_remove() { :; }

    # shellcheck disable=SC1090
    . "$(pkg_recipe "$pkg")"

    [ -n "${PKGNAME:-}" ] || die "recipe missing PKGNAME"
    [ -n "${PKGVER:-}" ] || die "recipe missing PKGVER"
    [ -n "${SRCURL:-}" ] || die "recipe missing SRCURL"
    [ -n "${SRCSHA256:-}" ] || die "recipe missing SRCSHA256"
    : "${BUILD_SYSTEM:=autotools}"
}

###############################################################################
# Build steps
###############################################################################
distfile_path() {
    # decide filename
    if [ -n "${SRCTARBALL:-}" ]; then
        printf '%s\n' "$XBUILD_DIST/$SRCTARBALL"
    else
        base=$(printf '%s\n' "$SRCURL" | awk -F/ '{print $NF}')
        [ -n "$base" ] || die "cannot infer filename from SRCURL"
        printf '%s\n' "$XBUILD_DIST/$base"
    fi
}

build_dir() {
    printf '%s\n' "$XBUILD_BUILD/${PKGNAME}-${PKGVER}"
}

src_top_dir() {
    # heuristically find first directory inside extraction root
    bdir=$(build_dir)
    # shellcheck disable=SC2012
    first=$(ls -1 "$bdir/src" 2>/dev/null | head -n 1 || true)
    [ -n "$first" ] || die "cannot determine extracted source dir"
    printf '%s\n' "$bdir/src/$first"
}

env_export() {
    export CC="$XBUILD_CC" CXX="$XBUILD_CXX" AR="$XBUILD_AR" RANLIB="$XBUILD_RANLIB" STRIP="$XBUILD_STRIP"
    export CFLAGS="$XBUILD_CFLAGS" CXXFLAGS="$XBUILD_CXXFLAGS" LDFLAGS="$XBUILD_LDFLAGS"
    export PKG_CONFIG="$XBUILD_PKG_CONFIG"
    # DESTDIR-style install root for staged installs
    export XBUILD_DESTDIR="$(build_dir)/dest"
}

fetch_verify() {
    pre_fetch
    arc=$(distfile_path)
    mkd "$XBUILD_DIST"
    if [ ! -f "$arc" ]; then
        msg "downloading: $SRCURL"
        download "$SRCURL" "$arc"
    else
        msg "using cached distfile: $arc"
    fi

    msg "verifying sha256"
    got=$(sha256_file "$arc")
    [ "$got" = "$SRCSHA256" ] || die "sha256 mismatch for $arc (got $got, expected $SRCSHA256)"
    post_fetch
}

extract_apply() {
    pre_extract
    bdir=$(build_dir)
    rm -rf "$bdir"
    mkd "$bdir/src" "$bdir/dest"
    arc=$(distfile_path)
    msg "extracting: $arc"
    extract "$arc" "$bdir/src"

    # apply patches if any
    if [ -n "${PATCHES:-}" ]; then
        need_cmd patch
        sdir=$(src_top_dir)
        for p in $PATCHES; do
            pf="$(pkg_dir "$PKGNAME")/$p"
            [ -f "$pf" ] || die "missing patch: $pf"
            msg "applying patch: $p"
            (cd "$sdir" && patch -p1 <"$pf")
        done
    fi
    post_extract
}

default_build() {
    sdir=$(src_top_dir)
    bdir=$(build_dir)
    log="$XBUILD_LOGS/${PKGNAME}-${PKGVER}.build.log"
    : >"$log"

    env_export

    case "$BUILD_SYSTEM" in
        autotools)
            msg "configure (autotools)"
            (cd "$sdir" && \
                run_logged "$log" sh -c \
                "./configure --prefix=$XBUILD_PREFIX ${CONFIGURE_ARGS:-}")
            msg "make"
            (cd "$sdir" && run_logged "$log" make -j "$XBUILD_MAKEJ")
            ;;
        cmake)
            need_cmd cmake
            mkd "$bdir/cmake-build"
            msg "configure (cmake)"
            (cd "$bdir/cmake-build" && \
                run_logged "$log" cmake \
                    -DCMAKE_INSTALL_PREFIX="$XBUILD_PREFIX" \
                    ${CMAKE_ARGS:-} \
                    "$sdir")
            msg "build (cmake)"
            (cd "$bdir/cmake-build" && run_logged "$log" cmake --build . -- -j "$XBUILD_MAKEJ")
            ;;
        meson)
            need_cmd meson
            need_cmd ninja
            mkd "$bdir/meson-build"
            msg "configure (meson)"
            (cd "$bdir/meson-build" && \
                run_logged "$log" meson setup \
                    --prefix "$XBUILD_PREFIX" \
                    ${MESON_ARGS:-} \
                    "$sdir")
            msg "build (ninja)"
            (cd "$bdir/meson-build" && run_logged "$log" ninja)
            ;;
        make)
            msg "make (plain)"
            (cd "$sdir" && run_logged "$log" make -j "$XBUILD_MAKEJ" ${MAKE_ARGS:-})
            ;;
        custom)
            die "BUILD_SYSTEM=custom requires do_build() in recipe"
            ;;
        *)
            die "unknown BUILD_SYSTEM: $BUILD_SYSTEM"
            ;;
    esac
}

default_install() {
    bdir=$(build_dir)
    sdir=$(src_top_dir)
    log="$XBUILD_LOGS/${PKGNAME}-${PKGVER}.install.log"
    : >"$log"

    env_export

    # stage into DESTDIR (build_dir/dest), then copy into sysroot
    case "$BUILD_SYSTEM" in
        autotools|make)
            msg "install (DESTDIR stage)"
            (cd "$sdir" && run_logged "$log" make DESTDIR="$XBUILD_DESTDIR" install)
            ;;
        cmake)
            msg "install (cmake DESTDIR stage)"
            (cd "$bdir/cmake-build" && run_logged "$log" cmake --install . --prefix "$XBUILD_PREFIX" --strip --config Release -- \
                DESTDIR="$XBUILD_DESTDIR" 2>/dev/null || true)
            # Some cmake versions don't accept DESTDIR via cmake --install.
            # Fallback to environment variable:
            if [ ! -d "$XBUILD_DESTDIR$XBUILD_PREFIX" ]; then
                (cd "$bdir/cmake-build" && DESTDIR="$XBUILD_DESTDIR" run_logged "$log" cmake --install .)
            fi
            ;;
        meson)
            msg "install (meson DESTDIR stage)"
            (cd "$bdir/meson-build" && DESTDIR="$XBUILD_DESTDIR" run_logged "$log" ninja install)
            ;;
        custom)
            die "BUILD_SYSTEM=custom requires do_install() in recipe"
            ;;
        *)
            die "unknown BUILD_SYSTEM: $BUILD_SYSTEM"
            ;;
    esac

    # copy staged files into target sysroot
    target="${XBUILD_SYSROOT:-}"
    if [ -n "$target" ]; then
        mkd "$target"
        msg "copying into sysroot: $target"
        (cd "$XBUILD_DESTDIR" && tar -cf - .) | (cd "$target" && tar -xpf -)
    else
        msg "copying into live system: /"
        (cd "$XBUILD_DESTDIR" && tar -cf - .) | (cd / && tar -xpf -)
    fi
}

record_install_db() {
    db="$(db_prefix)"
    rm -rf "$db"
    mkd "$db"
    # record file list (from staged destdir)
    (cd "$(build_dir)/dest" && find . -type f -o -type l -o -type d | sed 's|^\./||') >"$db/files"
    cat >"$db/meta" <<EOF
PKGNAME=$PKGNAME
PKGVER=$PKGVER
PREFIX=$XBUILD_PREFIX
SYSROOT=${XBUILD_SYSROOT:-/}
BUILD_SYSTEM=$BUILD_SYSTEM
EOF
}

is_installed() {
    [ -d "$(db_prefix)" ]
}

remove_pkg() {
    pkg=$1
    load_recipe "$pkg"
    db="$(db_prefix)"
    [ -d "$db" ] || die "not installed: $PKGNAME-$PKGVER"

    # Allow recipe to override removal logic if needed
    if command -v do_remove >/dev/null 2>&1; then
        # do_remove is always defined; check if recipe replaced it by checking meta trick:
        # We'll simply call it; default is ":".
        do_remove || die "custom remove failed"
    fi

    # Remove files in reverse depth order; ignore missing (user may have changed)
    msg "removing: $PKGNAME-$PKGVER"
    if [ -n "${XBUILD_SYSROOT:-}" ]; then
        root="$XBUILD_SYSROOT"
    else
        root="/"
    fi

    # Remove files listed; delete dirs after files
    # Separate dirs and non-dirs:
    awk '
        { print $0 }
    ' "$db/files" | while IFS= read -r rel; do
        [ -n "$rel" ] || continue
        path="$root/$rel"
        if [ -e "$path" ] || [ -L "$path" ]; then
            rm -f "$path" 2>/dev/null || true
        fi
    done

    # Best-effort cleanup of empty directories (deepest first)
    # shellcheck disable=SC2016
    awk 'NF{print}' "$db/files" | sort -r | while IFS= read -r rel; do
        [ -n "$rel" ] || continue
        d="$root/$rel"
        if [ -d "$d" ]; then
            rmdir "$d" 2>/dev/null || true
        fi
    done

    rm -rf "$db"
}

build_pkg() {
    pkg=$1
    load_recipe "$pkg"

    # Build deps first (simple, non-recursive loop)
    if [ -n "${DEPENDS:-}" ]; then
        for dep in $DEPENDS; do
            msg "dependency: $dep"
            "$0" install "$dep"
        done
    fi

    if is_installed; then
        msg "already installed: $PKGNAME-$PKGVER"
        return 0
    fi

    fetch_verify
    extract_apply

    pre_build
    if [ "$BUILD_SYSTEM" = "custom" ]; then
        msg "build (custom)"
        do_build
    else
        default_build
    fi
    post_build
}

install_pkg() {
    pkg=$1
    build_pkg "$pkg"

    load_recipe "$pkg" # ensure vars present
    pre_install
    if [ "$BUILD_SYSTEM" = "custom" ]; then
        msg "install (custom)"
        do_install
    else
        default_install
    fi
    post_install
    record_install_db
    msg "installed: $PKGNAME-$PKGVER"
}

list_pkgs() {
    # list available recipes
    [ -d "$XBUILD_PKGS" ] || exit 0
    # shellcheck disable=SC2012
    ls -1 "$XBUILD_PKGS" 2>/dev/null | awk 'NF{print}'
}

list_installed() {
    [ -d "$XBUILD_DB_ATTACH" ] && :
    [ -d "$XBUILD_DB" ] || exit 0
    # shellcheck disable=SC2012
    ls -1 "$XBUILD_DB" 2>/dev/null | awk 'NF{print}'
}

show_env() {
    load_config
    cat <<EOF
XBUILD_ROOT=$XBUILD_ROOT
XBUILD_DIST=$XBUILD_DIST
XBUILD_BUILD=$XBUILD_BUILD
XBUILD_PKGS=$XBUILD_PKGS
XBUILD_DB=$XBUILD_DB
XBUILD_LOGS=$XBUILD_LOGS

XBUILD_SYSROOT=${XBUILD_SYSROOT:-/}
XBUILD_PREFIX=$XBUILD_PREFIX
XBUILD_MAKEJ=$XBUILD_MAKEJ

XBUILD_CC=$XBUILD_CC
XBUILD_CXX=$XBUILD_CXX
XBUILD_AR=$XBUILD_AR
XBUILD_RANLIB=$XBUILD_RANLIB
XBUILD_STRIP=$XBUILD_STRIP
XBUILD_CFLAGS=$XBUILD_CFLAGS
XBUILD_CXXFLAGS=$XBUILD_CXXFLAGS
XBUILD_LDFLAGS=$XBUILD_LDFLAGS
XBUILD_PKG_CONFIG=$XBUILD_PKG_CONFIG
EOF
}

help() {
    cat <<EOF
Usage: xbuild <command> [args]

Commands:
  init                     Create root layout and default config
  env                      Show effective configuration
  list                     List available package recipes
  installed                List installed packages (from db)
  fetch <pkg>              Download + verify distfile
  build <pkg>              Fetch + verify + extract + build
  install <pkg>            Build + install + record in db
  remove <pkg>             Remove installed package files using db
  clean <pkg>              Remove build directory for package

Recipe format:
  root/pkgs/<name>/recipe  (POSIX sh fragment)
  Must define: PKGNAME PKGVER SRCURL SRCSHA256
  Optional: BUILD_SYSTEM DEPENDS PATCHES and hook functions.

Examples:
  ./xbuild init
  ./xbuild list
  ./xbuild install busybox
EOF
}

clean_pkg() {
    pkg=$1
    load_recipe "$pkg"
    rm -rf "$(build_dir)"
    msg "cleaned build dir: $PKGNAME-$PKGVER"
}

###############################################################################
# Main
###############################################################################
cmd=${1:-}
[ -n "$cmd" ] || { help; exit 1; }

# Always load config (except init which creates it)
if [ "$cmd" != "init" ]; then
    load_config
fi

case "$cmd" in
    init) init_layout ;;
    env) show_env ;;
    list) list_pkgs ;;
    installed) list_installed ;;
    fetch)
        [ $# -eq 2 ] || die "usage: xbuild fetch <pkg>"
        load_recipe "$2"; fetch_verify
        ;;
    build)
        [ $# -eq 2 ] || die "usage: xbuild build <pkg>"
        build_pkg "$2"
        ;;
    install)
        [ $# -eq 2 ] || die "usage: xbuild install <pkg>"
        install_pkg "$2"
        ;;
    remove)
        [ $# -eq 2 ] || die "usage: xbuild remove <pkg>"
        remove_pkg "$2"
        ;;
    clean)
        [ $# -eq 2 ] || die "usage: xbuild clean <pkg>"
        clean_pkg "$2"
        ;;
    -h|--help|help) help ;;
    *) die "unknown command: $cmd (use --help)" ;;
esac
