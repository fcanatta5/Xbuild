#!/bin/sh
# xbuild - POSIX build/recipe manager for a from-scratch x86_64 Linux system
# v0.5 
#
# Key properties:
# - POSIX sh (no bashisms)
# - Deterministic source dir detection (no ls-for-logic); optional SRCDIR override
# - Fetch + sha256 verify
# - Extract (tar.* / zip; optional zstd)
# - Optional patch application with configurable strip level
# - Build systems: autotools / cmake / meson / make / custom
# - Staged installs (DESTDIR) + manifest DB + safe-ish removal
# - Locking to prevent concurrent corruption
# - Rolling support: rebuild/upgrade (remove older versions of same PKGNAME)
# - Cross support hooks: configure host/build/target, meson cross-file, cmake toolchain
# - pkg-config sysroot integration knobs
#
# Layout (default under $XBUILD_ROOT):
#   root/
#     config
#     distfiles/
#     build/
#     pkgs/<name>/recipe
#     db/<PKGNAME>-<PKGVER>/{meta,files,dirs,recipe}
#     logs/
#
# Notes:
# - xbuild does not auto-discover upstream versions; for "stable rolling", you bump PKGVER+SRCSHA256 in recipes.
# - For BUILD_SYSTEM=custom, recipes MUST stage into $XBUILD_DESTDIR.
#
set -eu

###############################################################################
# Utilities
###############################################################################
die() { printf '%s\n' "xbuild: $*" >&2; exit 1; }
msg() { printf '%s\n' "==> $*" >&2; }

need_cmd() { command -v "$1" >/dev/null 2>&1 || die "missing required command: $1"; }

mkd() {
    # portable mkdir -p for 1..n args
    for d in "$@"; do
        [ -d "$d" ] || mkdir -p "$d"
    done
}

sha256_file() {
    if command -v sha256sum >/dev/null 2>&1; then
        sha256sum "$1" | awk '{print $1}'
    elif command -v shasum >/dev/null 2>&1; then
        shasum -a 256 "$1" | awk '{print $1}'
    else
        die "need sha256sum or shasum"
    fi
}

download() {
    # download URL to DEST (resume if possible)
    url=$1 dest=$2
    if command -v curl >/dev/null 2>&1; then
        curl -L --fail --retry 3 -C - -o "$dest".part "$url" || die "download failed: $url"
        mv "$dest".part "$dest"
    elif command -v wget >/dev/null 2>&1; then
        wget -O "$dest".part "$url" || die "download failed: $url"
        mv "$dest".part "$dest"
    else
        die "need curl or wget"
    fi
}

extract() {
    arc=$1 out=$2
    mkd "$out"
    case "$arc" in
        *.tar.gz|*.tgz)  tar -xzf "$arc" -C "$out" ;;
        *.tar.xz)        tar -xJf "$arc" -C "$out" ;;
        *.tar.bz2)       tar -xjf "$arc" -C "$out" ;;
        *.tar.zst)
            # GNU tar supports --zstd; fallback if absent
            if tar --help 2>/dev/null | grep -q -- '--zstd'; then
                tar --zstd -xf "$arc" -C "$out"
            else
                need_cmd zstd
                zstd -dc "$arc" | tar -xf - -C "$out"
            fi
            ;;
        *.tar)           tar -xf "$arc" -C "$out" ;;
        *.zip)           need_cmd unzip; unzip -q "$arc" -d "$out" ;;
        *) die "unknown archive format: $arc" ;;
    esac
}

run_logged() {
    logfile=$1; shift
    "$@" >>"$logfile" 2>&1
}

# Locking (atomic via mkdir)
LOCKDIR=""
lock_acquire() {
    LOCKDIR="$XBUILD_ROOT/.lock"
    # try a few times
    i=0
    while :; do
        if mkdir "$LOCKDIR" 2>/dev/null; then
            # record pid
            printf '%s\n' "$$" >"$LOCKDIR/pid" 2>/dev/null || true
            break
        fi
        i=$((i+1))
        [ "$i" -le 30 ] || die "lock busy: $LOCKDIR (another xbuild running?)"
        sleep 1
    done
}
lock_release() {
    [ -n "${LOCKDIR:-}" ] || return 0
    [ -d "$LOCKDIR" ] || return 0
    rm -rf "$LOCKDIR" 2>/dev/null || true
}
cleanup() {
    # always release lock
    lock_release
}
trap cleanup EXIT INT TERM

###############################################################################
# Configuration
###############################################################################
XBUILD_ROOT=${XBUILD_ROOT:-"$PWD/root"}
CONF="$XBUILD_ROOT/config"

# defaults (overridable in config)
XBUILD_DIST=${XBUILD_DIST:-"$XBUILD_ROOT/distfiles"}
XBUILD_BUILD=${XBUILD_BUILD:-"$XBUILD_ROOT/build"}
XBUILD_PKGS=${XBUILD_PKGS:-"$XBUILD_ROOT/pkgs"}
XBUILD_DB=${XBUILD_DB:-"$XBUILD_ROOT/db"}
XBUILD_LOGS=${XBUILD_LOGS:-"$XBUILD_ROOT/logs"}

XBUILD_SYSROOT=${XBUILD_SYSROOT:-""}         # e.g. /mnt/xbuild/rootfs (empty => live /)
XBUILD_PREFIX=${XBUILD_PREFIX:-/usr}
XBUILD_MAKEJ=${XBUILD_MAKEJ:-1}

# toolchain env (native defaults)
XBUILD_CC=${XBUILD_CC:-cc}
XBUILD_CXX=${XBUILD_CXX:-c++}
XBUILD_AR=${XBUILD_AR:-ar}
XBUILD_RANLIB=${XBUILD_RANLIB:-ranlib}
XBUILD_STRIP=${XBUILD_STRIP:-strip}

XBUILD_CFLAGS=${XBUILD_CFLAGS:-"-O2 -pipe"}
XBUILD_CXXFLAGS=${XBUILD_CXXFLAGS:-"$XBUILD_CFLAGS"}
XBUILD_LDFLAGS=${XBUILD_LDFLAGS:-""}

# pkg-config control (important for sysroot builds)
XBUILD_PKG_CONFIG=${XBUILD_PKG_CONFIG:-pkg-config}
XBUILD_PKG_CONFIG_SYSROOT_DIR=${XBUILD_PKG_CONFIG_SYSROOT_DIR:-""}
XBUILD_PKG_CONFIG_PATH=${XBUILD_PKG_CONFIG_PATH:-""}
XBUILD_PKG_CONFIG_LIBDIR=${XBUILD_PKG_CONFIG_LIBDIR:-""}

load_config() {
    if [ -f "$CONF" ]; then
        # shellcheck disable=SC1090
        . "$CONF"
    fi
    # ensure dirs are set even if config omits some fields
    XBUILD_DIST=${XBUILD_DIST:-"$XBUILD_ROOT/distfiles"}
    XBUILD_BUILD=${XBUILD_BUILD:-"$XBUILD_ROOT/build"}
    XBUILD_PKGS=${XBUILD_PKGS:-"$XBUILD_ROOT/pkgs"}
    XBUILD_DB=${XBUILD_DB:-"$XBUILD_ROOT/db"}
    XBUILD_LOGS=${XBUILD_LOGS:-"$XBUILD_ROOT/logs"}
}

init_layout() {
    mkd "$XBUILD_ROOT" "$XBUILD_DIST" "$XBUILD_BUILD" "$XBUILD_PKGS" "$XBUILD_DB" "$XBUILD_LOGS"
    if [ ! -f "$CONF" ]; then
        cat >"$CONF" <<EOF
# xbuild config (POSIX sh)

# Root directories:
XBUILD_ROOT="$XBUILD_ROOT"
XBUILD_DIST="$XBUILD_DIST"
XBUILD_BUILD="$XBUILD_BUILD"
XBUILD_PKGS="$XBUILD_PKGS"
XBUILD_DB="$XBUILD_DB"
XBUILD_LOGS="$XBUILD_LOGS"

# Install target:
# If building a fresh system under a mount point, set XBUILD_SYSROOT="/mnt/xbuild/rootfs"
XBUILD_SYSROOT="${XBUILD_SYSROOT}"
XBUILD_PREFIX="${XBUILD_PREFIX}"

# Parallel builds:
XBUILD_MAKEJ="${XBUILD_MAKEJ}"

# Toolchain:
XBUILD_CC="${XBUILD_CC}"
XBUILD_CXX="${XBUILD_CXX}"
XBUILD_AR="${XBUILD_AR}"
XBUILD_RANLIB="${XBUILD_RANLIB}"
XBUILD_STRIP="${XBUILD_STRIP}"

# Flags:
XBUILD_CFLAGS='${XBUILD_CFLAGS}'
XBUILD_CXXFLAGS='${XBUILD_CXXFLAGS}'
XBUILD_LDFLAGS='${XBUILD_LDFLAGS}'

# pkg-config knobs (useful for sysroot builds/cross):
# XBUILD_PKG_CONFIG="pkg-config"
# XBUILD_PKG_CONFIG_SYSROOT_DIR="/mnt/xbuild/rootfs"
# XBUILD_PKG_CONFIG_LIBDIR="/mnt/xbuild/rootfs/usr/lib/pkgconfig:/mnt/xbuild/rootfs/usr/share/pkgconfig"
# XBUILD_PKG_CONFIG_PATH=""
XBUILD_PKG_CONFIG='${XBUILD_PKG_CONFIG}'
XBUILD_PKG_CONFIG_SYSROOT_DIR='${XBUILD_PKG_CONFIG_SYSROOT_DIR}'
XBUILD_PKG_CONFIG_PATH='${XBUILD_PKG_CONFIG_PATH}'
XBUILD_PKG_CONFIG_LIBDIR='${XBUILD_PKG_CONFIG_LIBDIR}'
EOF
        msg "created config at $CONF"
    else
        msg "config already exists at $CONF"
    fi
}

###############################################################################
# Recipe handling
###############################################################################
pkg_dir() { printf '%s\n' "$XBUILD_PKGS/$1"; }
pkg_recipe() { printf '%s\n' "$(pkg_dir "$1")/recipe"; }

pkg_assert_exists() {
    [ -d "$(pkg_dir "$1")" ] || die "package not found: $1"
    [ -f "$(pkg_recipe "$1")" ] || die "missing recipe file: $(pkg_recipe "$1")"
}

db_prefix() { printf '%s\n' "$XBUILD_DB/${PKGNAME}-${PKGVER}"; }

# find any installed versions for PKGNAME
db_find_versions() {
    # prints: /path/to/db/PKGNAME-VER
    name=$1
    [ -d "$XBUILD_DB" ] || return 0
    find "$XBUILD_DB" -maxdepth 1 -mindepth 1 -type d -name "${name}-*" -print 2>/dev/null | awk 'NF{print}'
}

# load recipe into current shell:
# Must set: PKGNAME, PKGVER, SRCURL, SRCSHA256
# Optional (common):
#   SRCTARBALL, BUILD_SYSTEM, DEPENDS, PATCHES, PATCH_STRIP
#   SRCDIR (override extracted root dir; relative to src/)
#   CONFIGURE_ARGS, CMAKE_ARGS, MESON_ARGS, MAKE_ARGS
# Cross controls:
#   CONFIGURE_HOST, CONFIGURE_BUILD, CONFIGURE_TARGET
#   MESON_CROSS_FILE
#   CMAKE_TOOLCHAIN_FILE
# Hooks (optional functions):
#   pre_fetch/post_fetch/pre_extract/post_extract
#   pre_build/do_build/post_build
#   pre_install/do_install/post_install
#   do_remove
load_recipe() {
    pkg=$1
    pkg_assert_exists "$pkg"

    # reset vars
    PKGNAME= PKGVER= SRCURL= SRCSHA256= SRCTARBALL=
    BUILD_SYSTEM= DEPENDS= PATCHES= PATCH_STRIP=
    SRCDIR=
    CONFIGURE_ARGS= CMAKE_ARGS= MESON_ARGS= MAKE_ARGS=
    CONFIGURE_HOST= CONFIGURE_BUILD= CONFIGURE_TARGET=
    MESON_CROSS_FILE= CMAKE_TOOLCHAIN_FILE=

    # default hooks (no-op)
    pre_fetch() { :; }; post_fetch() { :; }
    pre_extract() { :; }; post_extract() { :; }
    pre_build() { :; }; do_build() { :; }; post_build() { :; }
    pre_install() { :; }; do_install() { :; }; post_install() { :; }
    do_remove() { :; }

    # shellcheck disable=SC1090
    . "$(pkg_recipe "$pkg")"

    [ -n "${PKGNAME:-}" ] || die "recipe missing PKGNAME"
    [ -n "${PKGVER:-}" ] || die "recipe missing PKGVER"
    [ -n "${SRCURL:-}" ] || die "recipe missing SRCURL"
    [ -n "${SRCSHA256:-}" ] || die "recipe missing SRCSHA256"
    : "${BUILD_SYSTEM:=autotools}"
    : "${PATCH_STRIP:=1}"
}

###############################################################################
# Paths and environment
###############################################################################
distfile_path() {
    if [ -n "${SRCTARBALL:-}" ]; then
        printf '%s\n' "$XBUILD_DIST/$SRCTARBALL"
    else
        base=$(printf '%s\n' "$SRCURL" | awk -F/ '{print $NF}')
        [ -n "$base" ] || die "cannot infer filename from SRCURL"
        printf '%s\n' "$XBUILD_DIST/$base"
    fi
}

build_dir() { printf '%s\n' "$XBUILD_BUILD/${PKGNAME}-${PKGVER}"; }

# deterministic, safe source dir selection:
# - if SRCDIR is set, use it relative to $bdir/src
# - else, pick a single top-level directory if exactly one exists; otherwise use src root
src_top_dir() {
    bdir=$(build_dir)
    [ -d "$bdir/src" ] || die "missing source tree: $bdir/src"

    if [ -n "${SRCDIR:-}" ]; then
        if [ -d "$bdir/src/$SRCDIR" ]; then
            printf '%s\n' "$bdir/src/$SRCDIR"
            return 0
        fi
        die "SRCDIR not found: $bdir/src/$SRCDIR"
    fi

    # find top-level directories
    dirs=$(find "$bdir/src" -mindepth 1 -maxdepth 1 -type d -print 2>/dev/null | awk 'NF{print}')
    ndirs=$(printf '%s\n' "$dirs" | awk 'NF{c++} END{print c+0}')

    if [ "$ndirs" -eq 1 ]; then
        printf '%s\n' "$dirs" | awk 'NR==1{print}'
        return 0
    fi

    # fallback: src root
    printf '%s\n' "$bdir/src"
}

env_export() {
    export CC="$XBUILD_CC" CXX="$XBUILD_CXX" AR="$XBUILD_AR" RANLIB="$XBUILD_RANLIB" STRIP="$XBUILD_STRIP"
    export CFLAGS="$XBUILD_CFLAGS" CXXFLAGS="$XBUILD_CXXFLAGS" LDFLAGS="$XBUILD_LDFLAGS"

    export PKG_CONFIG="$XBUILD_PKG_CONFIG"
    if [ -n "${XBUILD_PKG_CONFIG_SYSROOT_DIR:-}" ]; then
        export PKG_CONFIG_SYSROOT_DIR="$XBUILD_PKG_CONFIG_SYSROOT_DIR"
    fi
    if [ -n "${XBUILD_PKG_CONFIG_PATH:-}" ]; then
        export PKG_CONFIG_PATH="$XBUILD_PKG_CONFIG_PATH"
    fi
    if [ -n "${XBUILD_PKG_CONFIG_LIBDIR:-}" ]; then
        export PKG_CONFIG_LIBDIR="$XBUILD_PKG_CONFIG_LIBDIR"
    fi

    export XBUILD_DESTDIR="$(build_dir)/dest"
}

target_root() {
    if [ -n "${XBUILD_SYSROOT:-}" ]; then
        printf '%s\n' "$XBUILD_SYSROOT"
    else
        printf '%s\n' "/"
    fi
}

assert_staged_nonempty() {
    staged=$1
    [ -d "$staged" ] || die "staging dir missing: $staged"
    # has any entry?
    found=$(find "$staged" -mindepth 1 -print -quit 2>/dev/null || true)
    [ -n "$found" ] || die "staging dir is empty: $staged"
}

merge_staged_into_root() {
    staged=$1
    root=$(target_root)
    [ -d "$root" ] || mkd "$root"
    msg "merging staged files into: $root"
    (cd "$staged" && tar -cf - .) | (cd "$root" && tar -xpf -)
}

###############################################################################
# Core steps
###############################################################################
fetch_verify() {
    pre_fetch
    arc=$(distfile_path)
    mkd "$XBUILD_DIST"
    if [ ! -f "$arc" ]; then
        msg "downloading: $SRCURL"
        download "$SRCURL" "$arc"
    else
        msg "using cached distfile: $arc"
    fi
    msg "verifying sha256"
    got=$(sha256_file "$arc")
    [ "$got" = "$SRCSHA256" ] || die "sha256 mismatch for $arc (got $got, expected $SRCSHA256)"
    post_fetch
}

extract_apply() {
    pre_extract
    bdir=$(build_dir)
    rm -rf "$bdir"
    mkd "$bdir/src" "$bdir/dest"
    arc=$(distfile_path)
    msg "extracting: $arc"
    extract "$arc" "$bdir/src"

    if [ -n "${PATCHES:-}" ]; then
        need_cmd patch
        sdir=$(src_top_dir)
        for p in $PATCHES; do
            pf="$(pkg_dir "$PKGNAME")/$p"
            [ -f "$pf" ] || die "missing patch: $pf"
            msg "applying patch: $p (strip -p$PATCH_STRIP)"
            (cd "$sdir" && patch -p"$PATCH_STRIP" <"$pf")
        done
    fi
    post_extract
}

autotools_configure_flags() {
    # prints extra flags for configure (host/build/target)
    f=""
    [ -n "${CONFIGURE_HOST:-}" ] && f="$f --host=$CONFIGURE_HOST"
    [ -n "${CONFIGURE_BUILD:-}" ] && f="$f --build=$CONFIGURE_BUILD"
    [ -n "${CONFIGURE_TARGET:-}" ] && f="$f --target=$CONFIGURE_TARGET"
    printf '%s\n' "$f"
}

default_build() {
    sdir=$(src_top_dir)
    bdir=$(build_dir)
    log="$XBUILD_LOGS/${PKGNAME}-${PKGVER}.build.log"
    : >"$log"
    env_export

    case "$BUILD_SYSTEM" in
        autotools)
            msg "configure (autotools)"
            extra=$(autotools_configure_flags)
            # direct call (no sh -c)
            (cd "$sdir" && run_logged "$log" ./configure --prefix="$XBUILD_PREFIX" $extra $CONFIGURE_ARGS)
            msg "make"
            (cd "$sdir" && run_logged "$log" make -j "$XBUILD_MAKEJ")
            ;;
        cmake)
            need_cmd cmake
            mkd "$bdir/cmake-build"
            msg "configure (cmake)"
            tc=""
            [ -n "${CMAKE_TOOLCHAIN_FILE:-}" ] && tc="-DCMAKE_TOOLCHAIN_FILE=$CMAKE_TOOLCHAIN_FILE"
            (cd "$bdir/cmake-build" && run_logged "$log" cmake -DCMAKE_INSTALL_PREFIX="$XBUILD_PREFIX" $tc $CMAKE_ARGS "$sdir")
            msg "build (cmake)"
            (cd "$bdir/cmake-build" && run_logged "$log" cmake --build . -- -j "$XBUILD_MAKEJ")
            ;;
        meson)
            need_cmd meson
            need_cmd ninja
            mkd "$bdir/meson-build"
            msg "configure (meson)"
            cf=""
            [ -n "${MESON_CROSS_FILE:-}" ] && cf="--cross-file $MESON_CROSS_FILE"
            (cd "$bdir/meson-build" && run_logged "$log" meson setup --prefix "$XBUILD_PREFIX" $cf $MESON_ARGS "$sdir")
            msg "build (ninja)"
            (cd "$bdir/meson-build" && run_logged "$log" ninja)
            ;;
        make)
            msg "make (plain)"
            (cd "$sdir" && run_logged "$log" make -j "$XBUILD_MAKEJ" $MAKE_ARGS)
            ;;
        custom)
            die "BUILD_SYSTEM=custom requires do_build() in recipe"
            ;;
        *)
            die "unknown BUILD_SYSTEM: $BUILD_SYSTEM"
            ;;
    esac
}

default_install() {
    bdir=$(build_dir)
    sdir=$(src_top_dir)
    log="$XBUILD_LOGS/${PKGNAME}-${PKGVER}.install.log"
    : >"$log"
    env_export

    # Always stage into $XBUILD_DESTDIR and validate it becomes non-empty.
    case "$BUILD_SYSTEM" in
        autotools|make)
            msg "install (DESTDIR stage)"
            (cd "$sdir" && run_logged "$log" make DESTDIR="$XBUILD_DESTDIR" install)
            ;;
        cmake)
            msg "install (cmake DESTDIR stage)"
            # Many setups respect DESTDIR env var; validate after.
            (cd "$bdir/cmake-build" && DESTDIR="$XBUILD_DESTDIR" run_logged "$log" cmake --install . --prefix "$XBUILD_PREFIX")
            ;;
        meson)
            msg "install (meson DESTDIR stage)"
            (cd "$bdir/meson-build" && DESTDIR="$XBUILD_DESTDIR" run_logged "$log" ninja install)
            ;;
        custom)
            die "BUILD_SYSTEM=custom requires do_install() in recipe"
            ;;
        *)
            die "unknown BUILD_SYSTEM: $BUILD_SYSTEM"
            ;;
    esac

    assert_staged_nonempty "$XBUILD_DESTDIR"
    merge_staged_into_root "$XBUILD_DESTDIR"
}

record_install_db() {
    db="$(db_prefix)"
    rm -rf "$db"
    mkd "$db"
    staged="$(build_dir)/dest"

    # Meta
    cat >"$db/meta" <<EOF
PKGNAME=$PKGNAME
PKGVER=$PKGVER
PREFIX=$XBUILD_PREFIX
SYSROOT=$(target_root)
BUILD_SYSTEM=$BUILD_SYSTEM
INSTALLED_AT=$(date -u '+%Y-%m-%dT%H:%M:%SZ' 2>/dev/null || date)
EOF

    # Save recipe snapshot for reproducibility/audit
    cp "$(pkg_recipe "$PKGNAME")" "$db/recipe" 2>/dev/null || true

    # Manifests:
    # - files: regular files + symlinks + fifos + device nodes (if any)
    # - dirs : directories (excluding '.')
    (cd "$staged" && find . \( -type f -o -type l -o -type p -o -type b -o -type c \) -print | sed 's|^\./||' | awk 'NF{print}') >"$db/files"
    (cd "$staged" && find . -type d -print | sed 's|^\./||' | awk 'NF && $0!="."{print}') >"$db/dirs"
}

is_installed_exact() { [ -d "$(db_prefix)" ]; }

remove_db_entry() {
    dbpath=$1
    [ -d "$dbpath" ] || return 0
    root=$(target_root)

    # try read meta for name/ver message, but do not depend on it
    name=$(awk -F= '/^PKGNAME=/{print $2}' "$dbpath/meta" 2>/dev/null || true)
    ver=$(awk -F= '/^PKGVER=/{print $2}' "$dbpath/meta" 2>/dev/null || true)
    [ -n "$name" ] && [ -n "$ver" ] && msg "removing: $name-$ver from $root"

    # remove files
    if [ -f "$dbpath/files" ]; then
        while IFS= read -r rel; do
            [ -n "$rel" ] || continue
            path="$root/$rel"
            if [ -e "$path" ] || [ -L "$path" ]; then
                rm -f "$path" 2>/dev/null || true
            fi
        done <"$dbpath/files"
    fi

    # remove dirs deepest-first by length
    if [ -f "$dbpath/dirs" ]; then
        awk '{print length($0) ":" $0}' "$dbpath/dirs" | sort -rn | cut -d: -f2- | while IFS= read -r rel; do
            [ -n "$rel" ] || continue
            d="$root/$rel"
            if [ -d "$d" ]; then
                rmdir "$d" 2>/dev/null || true
            fi
        done
    fi

    rm -rf "$dbpath"
}

remove_pkg() {
    pkg=$1
    load_recipe "$pkg"
    db="$(db_prefix)"
    [ -d "$db" ] || die "not installed: $PKGNAME-$PKGVER"

    # allow recipe to perform special cleanup (default is no-op)
    do_remove || die "custom remove failed"

    remove_db_entry "$db"
}

remove_all_versions() {
    name=$1
    for d in $(db_find_versions "$name"); do
        remove_db_entry "$d"
    done
}

build_pkg() {
    pkg=$1
    load_recipe "$pkg"

    # deps first
    if [ -n "${DEPENDS:-}" ]; then
        for dep in $DEPENDS; do
            msg "dependency: $dep"
            "$0" install "$dep"
        done
    fi

    if is_installed_exact; then
        msg "already installed: $PKGNAME-$PKGVER"
        return 0
    fi

    fetch_verify
    extract_apply

    pre_build
    if [ "$BUILD_SYSTEM" = "custom" ]; then
        msg "build (custom)"
        env_export
        do_build
    else
        default_build
    fi
    post_build
}

rebuild_pkg() {
    pkg=$1
    load_recipe "$pkg"

    # deps first (rebuild does not force rebuild of deps)
    if [ -n "${DEPENDS:-}" ]; then
        for dep in $DEPENDS; do
            msg "dependency: $dep"
            "$0" install "$dep"
        done
    fi

    fetch_verify
    extract_apply

    pre_build
    if [ "$BUILD_SYSTEM" = "custom" ]; then
        msg "build (custom)"
        env_export
        do_build
    else
        default_build
    fi
    post_build
}

install_pkg() {
    pkg=$1
    build_pkg "$pkg"
    load_recipe "$pkg"

    pre_install
    if [ "$BUILD_SYSTEM" = "custom" ]; then
        msg "install (custom)"
        env_export
        do_install
        assert_staged_nonempty "$XBUILD_DESTDIR"
        merge_staged_into_root "$XBUILD_DESTDIR"
    else
        default_install
    fi
    post_install

    record_install_db
    msg "installed: $PKGNAME-$PKGVER"
}

reinstall_pkg() {
    # rebuild + install even if already installed (same version)
    pkg=$1
    rebuild_pkg "$pkg"
    load_recipe "$pkg"

    pre_install
    if [ "$BUILD_SYSTEM" = "custom" ]; then
        msg "install (custom)"
        env_export
        do_install
        assert_staged_nonempty "$XBUILD_DESTDIR"
        merge_staged_into_root "$XBUILD_DESTDIR"
    else
        default_install
    fi
    post_install

    record_install_db
    msg "reinstalled: $PKGNAME-$PKGVER"
}

upgrade_pkg() {
    # install recipe version; remove older versions of same PKGNAME
    pkg=$1
    load_recipe "$pkg"

    # if exact version already installed, treat as no-op
    if is_installed_exact; then
        msg "already at version: $PKGNAME-$PKGVER"
        return 0
    fi

    # install new version
    install_pkg "$pkg"

    # remove all other versions of the same name (best-effort)
    for d in $(db_find_versions "$PKGNAME"); do
        # keep current
        case "$d" in
            */"$PKGNAME"-"$PKGVER") : ;;
            *) remove_db_entry "$d" ;;
        esac
    done
}

list_pkgs() {
    [ -d "$XBUILD_PKGS" ] || exit 0
    ls -1 "$XBUILD_PKGS" 2>/dev/null | awk 'NF{print}'
}

list_installed() {
    [ -d "$XBUILD_DB" ] || exit 0
    ls -1 "$XBUILD_DB" 2>/dev/null | awk 'NF{print}'
}

show_env() {
    load_config
    cat <<EOF
XBUILD_ROOT=$XBUILD_ROOT
XBUILD_DIST=$XBUILD_DIST
XBUILD_BUILD=$XBUILD_BUILD
XBUILD_PKGS=$XBUILD_PKGS
XBUILD_DB=$XBUILD_DB
XBUILD_LOGS=$XBUILD_LOGS

XBUILD_SYSROOT=$(target_root)
XBUILD_PREFIX=$XBUILD_PREFIX
XBUILD_MAKEJ=$XBUILD_MAKEJ

XBUILD_CC=$XBUILD_CC
XBUILD_CXX=$XBUILD_CXX
XBUILD_AR=$XBUILD_AR
XBUILD_RANLIB=$XBUILD_RANLIB
XBUILD_STRIP=$XBUILD_STRIP
XBUILD_CFLAGS=$XBUILD_CFLAGS
XBUILD_CXXFLAGS=$XBUILD_CXXFLAGS
XBUILD_LDFLAGS=$XBUILD_LDFLAGS

XBUILD_PKG_CONFIG=$XBUILD_PKG_CONFIG
XBUILD_PKG_CONFIG_SYSROOT_DIR=${XBUILD_PKG_CONFIG_SYSROOT_DIR:-}
XBUILD_PKG_CONFIG_PATH=${XBUILD_PKG_CONFIG_PATH:-}
XBUILD_PKG_CONFIG_LIBDIR=${XBUILD_PKG_CONFIG_LIBDIR:-}
EOF
}

clean_pkg() {
    pkg=$1
    load_recipe "$pkg"
    rm -rf "$(build_dir)"
    msg "cleaned build dir: $PKGNAME-$PKGVER"
}

help() {
    cat <<EOF
Usage: xbuild <command> [args]

Core:
  init                     Create root layout and default config
  env                      Show effective configuration
  list                     List available package recipes
  installed                List installed packages (from db)
  fetch <pkg>              Download + verify distfile
  build <pkg>              Fetch + verify + extract + build (no install)
  install <pkg>            Build + install + record in db
  remove <pkg>             Remove installed package (exact recipe version)
  clean <pkg>              Remove build directory for package

Rolling / maintenance:
  rebuild <pkg>            Force rebuild+reinstall for the recipe version (even if installed)
  upgrade <pkg>            Install recipe version then remove other installed versions of same PKGNAME
  purge <pkgname>          Remove ALL installed versions matching PKGNAME-*

Recipe format:
  \$XBUILD_PKGS/<name>/recipe  (POSIX sh fragment)
  Must define:
    PKGNAME PKGVER SRCURL SRCSHA256
  Optional:
    BUILD_SYSTEM (autotools|cmake|meson|make|custom)
    DEPENDS PATCHES PATCH_STRIP SRCDIR
    CONFIGURE_ARGS CMAKE_ARGS MESON_ARGS MAKE_ARGS
  Cross knobs:
    CONFIGURE_HOST CONFIGURE_BUILD CONFIGURE_TARGET
    MESON_CROSS_FILE
    CMAKE_TOOLCHAIN_FILE

Notes:
  - Default installs always stage into build/<pkg-ver>/dest then merge into SYSROOT.
  - For BUILD_SYSTEM=custom, recipes MUST stage into \$XBUILD_DESTDIR.
  - Concurrency: xbuild uses a simple lock at \$XBUILD_ROOT/.lock.

EOF
}

###############################################################################
# Main
###############################################################################
cmd=${1:-}
[ -n "$cmd" ] || { help; exit 1; }

if [ "$cmd" != "init" ]; then
    load_config
    mkd "$XBUILD_ROOT" "$XBUILD_DIST" "$XBUILD_BUILD" "$XBUILD_PKGS" "$XBUILD_DB" "$XBUILD_LOGS"
    lock_acquire
fi

case "$cmd" in
    init) init_layout ;;
    env) show_env ;;
    list) list_pkgs ;;
    installed) list_installed ;;
    fetch)
        [ $# -eq 2 ] || die "usage: xbuild fetch <pkg>"
        load_recipe "$2"
        fetch_verify
        ;;
    build)
        [ $# -eq 2 ] || die "usage: xbuild build <pkg>"
        build_pkg "$2"
        ;;
    install)
        [ $# -eq 2 ] || die "usage: xbuild install <pkg>"
        install_pkg "$2"
        ;;
    rebuild)
        [ $# -eq 2 ] || die "usage: xbuild rebuild <pkg>"
        reinstall_pkg "$2"
        ;;
    upgrade)
        [ $# -eq 2 ] || die "usage: xbuild upgrade <pkg>"
        upgrade_pkg "$2"
        ;;
    remove)
        [ $# -eq 2 ] || die "usage: xbuild remove <pkg>"
        remove_pkg "$2"
        ;;
    purge)
        [ $# -eq 2 ] || die "usage: xbuild purge <pkgname>"
        remove_all_versions "$2"
        ;;
    clean)
        [ $# -eq 2 ] || die "usage: xbuild clean <pkg>"
        clean_pkg "$2"
        ;;
    -h|--help|help) help ;;
    *) die "unknown command: $cmd (use 'xbuild help')" ;;
esac
