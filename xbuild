#!/bin/sh
# XBUILD_VERSION="0.0.1"
# License: MIT-0 (do whatever you want, no warranty).

# -------- Defaults (override via environment) --------
: "${XBUILD_PREFIX:=/usr}"
: "${XBUILD_ROOTFS:=/}"                 # final root ("/" for live system, or a rootfs dir)
: "${XBUILD_RECIPES:=/etc/xbuild/recipes}"
: "${XBUILD_WORK:=/var/lib/xbuild}"
: "${XBUILD_CACHE:=$XBUILD_WORK/cache}"
: "${XBUILD_SOURCES:=$XBUILD_CACHE/sources}"
: "${XBUILD_BUILDDIR:=$XBUILD_WORK/build}"
: "${XBUILD_STAGING:=$XBUILD_WORK/staging}"   # per-package DESTDIR
: "${XBUILD_DB:=$XBUILD_WORK/db}"            # installed manifests + metadata
: "${XBUILD_LOGS:=$XBUILD_WORK/logs}"
: "${XBUILD_JOBS:=$(getconf _NPROCESSORS_ONLN 2>/dev/null || echo 1)}"
: "${XBUILD_UMASK:=022}"
: "${XBUILD_KEEP_BUILD:=0}"            # 1 keeps build dir after success
: "${XBUILD_VERIFY_TLS:=1}"            # 0 passes -k to curl (not recommended)
: "${XBUILD_ASSUME_YES:=0}"            # 1 skips prompts for destructive actions
: "${XBUILD_STRICT:=1}"                # 1 enables stricter checks
: "${XBUILD_FORCE:=0}"                 # 1 allows file collisions with installed packages

umask "$XBUILD_UMASK" 2>/dev/null || :

# -------- Helpers --------
die() { printf '%s\n' "xbuild: ERROR: $*" >&2; exit 1; }
warn(){ printf '%s\n' "xbuild: WARN:  $*" >&2; }
msg() { printf '%s\n' "xbuild: $*"; }

need_cmd() { command -v "$1" >/dev/null 2>&1 || die "missing command: $1"; }

is_abs() { case "$1" in /*) return 0;; *) return 1;; esac; }

mkp() { mkdir -p "$1" || die "cannot create directory: $1"; }

now_utc() { date -u '+%Y-%m-%dT%H:%M:%SZ' 2>/dev/null || date; }

safe_rm_rf() {
    p=$1
    [ -n "$p" ] || die "internal: empty path in rm"
    [ "$p" != "/" ] || die "refusing to remove /"
    rm -rf -- "$p" 2>/dev/null || rm -rf "$p" || die "cannot remove: $p"
}

confirm() {
    [ "$XBUILD_ASSUME_YES" = "1" ] && return 0
    printf '%s' "xbuild: $1 [y/N] " >&2
    IFS= read -r ans || return 1
    case "$ans" in y|Y|yes|YES) return 0;; *) return 1;; esac
}

# -------- Locking (stale-lock aware) --------
LOCKDIR=
lock_acquire() {
    LOCKDIR="$XBUILD_WORK/.lock"
    mkp "$XBUILD_WORK"
    i=0
    while ! mkdir "$LOCKDIR" 2>/dev/null; do
        # stale lock recovery
        if [ -f "$LOCKDIR/pid" ]; then
            lpid=$(cat "$LOCKDIR/pid" 2>/dev/null || echo "")
            case "$lpid" in
                ''|*[!0-9]*) : ;;
                *)
                    if kill -0 "$lpid" 2>/dev/null; then
                        : # still running
                    else
                        warn "stale lock detected (pid=$lpid); recovering"
                        safe_rm_rf "$LOCKDIR"
                        continue
                    fi
                    ;;
            esac
        fi
        i=$((i+1))
        [ "$i" -le 120 ] || die "lock timeout (another xbuild running?)"
        sleep 1
    done
    echo "$$" >"$LOCKDIR/pid" 2>/dev/null || :
}
lock_release() {
    [ -n "${LOCKDIR:-}" ] || return 0
    safe_rm_rf "$LOCKDIR" 2>/dev/null || :
    LOCKDIR=
}

# -------- Cleanup / traps (avoid exit recursion) --------
XBUILD_TMPDIR=
cleanup_common() {
    [ -n "${XBUILD_TMPDIR:-}" ] && [ -d "$XBUILD_TMPDIR" ] && safe_rm_rf "$XBUILD_TMPDIR" 2>/dev/null || :
    lock_release
}

on_exit() { cleanup_common; }
on_signal() { st=$?; cleanup_common; exit "${st:-1}"; }

trap on_signal INT TERM HUP
trap on_exit EXIT

# -------- Usage --------
usage() {
cat <<'EOF'
xbuild - minimal source fetch/build/install manager

USAGE:
  xbuild <cmd> [options] <pkg>
  xbuild <cmd> [options] <category/pkg>
  xbuild remove|r [options] <pkgid>   (e.g., zlib-1.3.1)

COMMANDS (and abbreviations):
  fetch      (f)     Download source tarball + verify SHA256 + store in cache
  build      (b)     Unpack + build in isolated build dir
  install    (i)     Stage install into DESTDIR + register + then copy into ROOTFS
  remove     (r)     Uninstall registered files from ROOTFS (by pkgid or by recipe ref)
  list       (ls)    List installed packages
  info       (in)    Show recipe + installed metadata
  clean      (cl)    Remove build/staging dirs for a package (keeps sources)
  help       (h)     Show help

OPTIONS:
  -R, --rootfs PATH       Final root (default: /)
  -P, --prefix PATH       Prefix inside ROOTFS (default: /usr)
  -r, --recipes PATH      Recipes directory (default: /etc/xbuild/recipes)
  -j, --jobs N            Parallel jobs (default: detected CPU count)
  -k, --keep-build         Keep build dir after success
  -y, --yes               Assume "yes" for prompts
  -q, --quiet             Less output
  -v, --verbose           More output

ENV overrides:
  XBUILD_ROOTFS XBUILD_PREFIX XBUILD_RECIPES XBUILD_WORK XBUILD_CACHE XBUILD_SOURCES
  XBUILD_BUILDDIR XBUILD_STAGING XBUILD_DB XBUILD_LOGS XBUILD_JOBS XBUILD_KEEP_BUILD
  XBUILD_ASSUME_YES XBUILD_STRICT XBUILD_FORCE

RECIPE FORMAT:
  $XBUILD_RECIPES/<category>/<name>.sh

Required variables:
  PKG_NAME, PKG_VERSION, PKG_URL, PKG_SHA256

Optional variables:
  PKG_ARCHIVE   (filename; default derived from URL)
  PKG_DIRNAME   (dir inside archive; default derived)
  PKG_SITE      (homepage/info)
  PKG_LICENSE
  PKG_DEPENDS   (space-separated)
  PKG_BUILD_SYSTEM: autotools|cmake|meson|make|custom (default: autotools)
  PKG_CONFIGURE_OPTS
  PKG_MAKE_OPTS
  PKG_INSTALL_OPTS
  PKG_PATCHES   (space-separated patch file paths)
  PKG_ENV       (extra VAR=VAL pairs exported during build/install)
  PKG_PRE_BUILD, PKG_POST_BUILD (shell snippets)
  PKG_PRE_INSTALL, PKG_POST_INSTALL
  PKG_CUSTOM_BUILD, PKG_CUSTOM_INSTALL

Examples:
  xbuild fetch busybox
  xbuild b base/busybox
  xbuild i base/busybox -R /mnt/rootfs
  xbuild r busybox-1.36.1 -R /mnt/rootfs
EOF
}

# -------- Logging / command execution --------
QUIET=0
VERBOSE=0
logfile=

run_strict() {
    # logs to $logfile and also prints to stderr (unless quiet), preserving exit status
    if [ "$QUIET" -eq 1 ]; then
        "$@" >>"$logfile" 2>&1
        return $?
    fi
    tf="$XBUILD_TMPDIR/cmd.out"
    : >"$tf" || die "cannot write temp output"
    "$@" >>"$tf" 2>&1
    rc=$?
    cat "$tf" >>"$logfile" 2>/dev/null || :
    cat "$tf" 1>&2
    return $rc
}

# -------- Download --------
downloader_detect() {
    if command -v curl >/dev/null 2>&1; then echo "curl"; return 0; fi
    if command -v wget >/dev/null 2>&1; then echo "wget"; return 0; fi
    die "need curl or wget for downloads"
}

download_file() {
    url=$1; out=$2
    dl=$(downloader_detect)
    case "$dl" in
        curl)
            tlsflag=
            [ "$XBUILD_VERIFY_TLS" = "0" ] && tlsflag="-k"
            run_strict curl $tlsflag -L --fail --retry 3 --retry-delay 2 -o "$out" "$url"
            ;;
        wget)
            run_strict wget -O "$out" "$url"
            ;;
    esac
}

sha256_check() {
    file=$1; expected=$2
    need_cmd sha256sum
    got=$(sha256sum "$file" | awk '{print $1}')
    [ "$got" = "$expected" ] || die "sha256 mismatch for $(basename "$file"): expected $expected got $got"
}

# -------- Recipe loading --------
recipe_find() {
    arg=$1
    case "$arg" in
        */*) cat=${arg%/*}; name=${arg##*/};;
        *) cat=""; name="$arg";;
    esac
    if [ -n "$cat" ]; then
        f="$XBUILD_RECIPES/$cat/$name.sh"
        [ -f "$f" ] && { echo "$f"; return 0; }
        die "recipe not found: $arg (expected $f)"
    fi
    f=$(ls -1 "$XBUILD_RECIPES"/*/"$name".sh 2>/dev/null | awk 'NR==1{print;exit}')
    [ -n "$f" ] && [ -f "$f" ] && { echo "$f"; return 0; }
    die "recipe not found by name: $name"
}

recipe_load() {
    recipe_file=$1
    PKG_NAME= PKG_VERSION= PKG_URL= PKG_SHA256=
    PKG_ARCHIVE= PKG_DIRNAME= PKG_SITE= PKG_LICENSE=
    PKG_DEPENDS= PKG_BUILD_SYSTEM= PKG_CONFIGURE_OPTS=
    PKG_MAKE_OPTS= PKG_INSTALL_OPTS= PKG_PATCHES=
    PKG_ENV= PKG_PRE_BUILD= PKG_POST_BUILD= PKG_PRE_INSTALL= PKG_POST_INSTALL=
    PKG_CUSTOM_BUILD= PKG_CUSTOM_INSTALL=
    # shellcheck disable=SC1090
    . "$recipe_file" || die "failed to source recipe: $recipe_file"
    [ -n "$PKG_NAME" ] || die "recipe missing PKG_NAME ($recipe_file)"
    [ -n "$PKG_VERSION" ] || die "recipe missing PKG_VERSION ($recipe_file)"
    [ -n "$PKG_URL" ] || die "recipe missing PKG_URL ($recipe_file)"
    [ -n "$PKG_SHA256" ] || die "recipe missing PKG_SHA256 ($recipe_file)"
    : "${PKG_BUILD_SYSTEM:=autotools}"
    if [ -z "$PKG_ARCHIVE" ]; then
        PKG_ARCHIVE=${PKG_URL##*/}
        [ -n "$PKG_ARCHIVE" ] || die "cannot derive PKG_ARCHIVE from URL"
    fi
    if [ -z "$PKG_DIRNAME" ]; then
        d=$PKG_ARCHIVE
        for suf in .tar.gz .tgz .tar.xz .tar.bz2 .tbz2 .tar.zst .zip; do
            case "$d" in *"$suf") d=${d%"$suf"};; esac
        done
        PKG_DIRNAME=$d
    fi
    PKG_ID=$(printf '%s-%s' "$PKG_NAME" "$PKG_VERSION")
    PKG_CAT=$(basename "$(dirname "$recipe_file")" 2>/dev/null || echo "unknown")
    PKG_REF="$PKG_CAT/$PKG_NAME"
}

# -------- Build paths --------
paths_init() {
    mkp "$XBUILD_WORK"
    mkp "$XBUILD_CACHE"
    mkp "$XBUILD_SOURCES"
    mkp "$XBUILD_BUILDDIR"
    mkp "$XBUILD_STAGING"
    mkp "$XBUILD_DB"
    mkp "$XBUILD_LOGS"
    XBUILD_TMPDIR="$XBUILD_WORK/tmp.$$"
    mkp "$XBUILD_TMPDIR"
    SRCFILE="$XBUILD_SOURCES/$PKG_ARCHIVE"
    BUILDD="$XBUILD_BUILDDIR/$PKG_ID"
    STAGED="$XBUILD_STAGING/$PKG_ID"
    PKG_DB="$XBUILD_DB/$PKG_ID"
    mkp "$PKG_DB"
    logfile="$XBUILD_LOGS/$PKG_ID.$CMD.$(date -u '+%Y%m%dT%H%M%SZ' 2>/dev/null || date '+%Y%m%d%H%M%S').log"
    : >"$logfile" || die "cannot write log: $logfile"
}

# -------- Unpack / patch --------
unpack_source() {
    safe_rm_rf "$BUILDD" 2>/dev/null || :
    mkp "$BUILDD"
    case "$SRCFILE" in
        *.tar.gz|*.tgz)   run_strict tar -xzf "$SRCFILE" -C "$BUILDD" ;;
        *.tar.xz)         run_strict tar -xJf "$SRCFILE" -C "$BUILDD" ;;
        *.tar.bz2|*.tbz2) run_strict tar -xjf "$SRCFILE" -C "$BUILDD" ;;
        *.tar.zst)        need_cmd zstd; run_strict tar --use-compress-program=zstd -xf "$SRCFILE" -C "$BUILDD" ;;
        *.zip)            need_cmd unzip; run_strict unzip -q "$SRCFILE" -d "$BUILDD" ;;
        *) die "unknown archive format: $SRCFILE" ;;
    esac
    SRCDIR="$BUILDD/$PKG_DIRNAME"
    [ -d "$SRCDIR" ] || {
        d=$(find "$BUILDD" -mindepth 1 -maxdepth 1 -type d 2>/dev/null | awk 'NR==1{print;exit}')
        [ -n "$d" ] && SRCDIR="$d"
        [ -d "$SRCDIR" ] || die "source dir not found after unpack (expected $BUILDD/$PKG_DIRNAME)"
    }
    if [ -n "${PKG_PATCHES:-}" ]; then
        need_cmd patch
        for p in $PKG_PATCHES; do
            [ -f "$p" ] || die "patch not found: $p"
            msg "applying patch: $p"
            (cd "$SRCDIR" && run_strict patch -p1 <"$p") || die "patch failed: $p"
        done
    fi
}

# -------- Build / Install logic --------
export_env() {
    export PREFIX="$XBUILD_PREFIX"
    export DESTDIR="$STAGED/destdir"
    export MAKEFLAGS="-j$XBUILD_JOBS"
    if [ -n "${PKG_ENV:-}" ]; then
        for kv in $PKG_ENV; do
            case "$kv" in *=*) export "$kv" ;; *) die "invalid PKG_ENV token (need VAR=VAL): $kv" ;; esac
        done
    fi
}

do_build() {
    export_env
    [ -n "${PKG_PRE_BUILD:-}" ] && (cd "$SRCDIR" && sh -c "$PKG_PRE_BUILD") || :
    case "$PKG_BUILD_SYSTEM" in
        autotools)
            [ -x "$SRCDIR/configure" ] || die "configure not found (set PKG_BUILD_SYSTEM or PKG_DIRNAME): $SRCDIR"
            (cd "$SRCDIR" && run_strict ./configure --prefix="$XBUILD_PREFIX" $PKG_CONFIGURE_OPTS) || die "configure failed"
            (cd "$SRCDIR" && run_strict make $PKG_MAKE_OPTS) || die "make failed"
            ;;
        cmake)
            need_cmd cmake
            mkp "$SRCDIR/.xbuild-cmake"
            (cd "$SRCDIR/.xbuild-cmake" && run_strict cmake -DCMAKE_INSTALL_PREFIX="$XBUILD_PREFIX" $PKG_CONFIGURE_OPTS ..) || die "cmake configure failed"
            (cd "$SRCDIR/.xbuild-cmake" && run_strict cmake --build . -- -j"$XBUILD_JOBS" $PKG_MAKE_OPTS) || die "cmake build failed"
            ;;
        meson)
            need_cmd meson; need_cmd ninja
            mkp "$SRCDIR/.xbuild-meson"
            (cd "$SRCDIR" && run_strict meson setup .xbuild-meson --prefix "$XBUILD_PREFIX" $PKG_CONFIGURE_OPTS) || die "meson setup failed"
            (cd "$SRCDIR/.xbuild-meson" && run_strict ninja) || die "ninja build failed"
            ;;
        make)
            (cd "$SRCDIR" && run_strict make $PKG_MAKE_OPTS) || die "make failed"
            ;;
        custom)
            [ -n "${PKG_CUSTOM_BUILD:-}" ] || die "PKG_BUILD_SYSTEM=custom requires PKG_CUSTOM_BUILD"
            (cd "$SRCDIR" && sh -c "$PKG_CUSTOM_BUILD") || die "custom build failed"
            ;;
        *)
            die "unknown PKG_BUILD_SYSTEM: $PKG_BUILD_SYSTEM"
            ;;
    esac
    [ -n "${PKG_POST_BUILD:-}" ] && (cd "$SRCDIR" && sh -c "$PKG_POST_BUILD") || :
}

do_stage_install() {
    export_env
    safe_rm_rf "$DESTDIR" 2>/dev/null || :
    mkp "$DESTDIR"
    [ -n "${PKG_PRE_INSTALL:-}" ] && (cd "$SRCDIR" && sh -c "$PKG_PRE_INSTALL") || :
    case "$PKG_BUILD_SYSTEM" in
        autotools|make)
            (cd "$SRCDIR" && run_strict make DESTDIR="$DESTDIR" install $PKG_INSTALL_OPTS) || die "install failed"
            ;;
        cmake)
            # CMake honors DESTDIR env; avoid unsupported flags for portability.
            (cd "$SRCDIR/.xbuild-cmake" && DESTDIR="$DESTDIR" run_strict cmake --install . --prefix "$XBUILD_PREFIX" $PKG_INSTALL_OPTS) || die "cmake install failed"
            ;;
        meson)
            (cd "$SRCDIR/.xbuild-meson" && DESTDIR="$DESTDIR" run_strict ninja install) || die "meson install failed"
            ;;
        custom)
            [ -n "${PKG_CUSTOM_INSTALL:-}" ] || die "PKG_BUILD_SYSTEM=custom requires PKG_CUSTOM_INSTALL"
            (cd "$SRCDIR" && sh -c "$PKG_CUSTOM_INSTALL") || die "custom install failed"
            ;;
    esac
    [ -n "${PKG_POST_INSTALL:-}" ] && (cd "$SRCDIR" && sh -c "$PKG_POST_INSTALL") || :
}

manifest_write() {
    mkp "$PKG_DB"
    MANIFEST="$PKG_DB/manifest.txt"
    META="$PKG_DB/meta.txt"
    : >"$MANIFEST" || die "cannot write manifest"

    # record files relative to ROOTFS, excluding directories
    (cd "$DESTDIR" && find . \( -type f -o -type l \) -print) |
        sed 's|^\./||' | sort >"$MANIFEST"

    {
        echo "pkg_id=$PKG_ID"
        echo "name=$PKG_NAME"
        echo "version=$PKG_VERSION"
        echo "ref=$PKG_REF"
        echo "prefix=$XBUILD_PREFIX"
        echo "rootfs=$XBUILD_ROOTFS"
        echo "build_system=$PKG_BUILD_SYSTEM"
        echo "url=$PKG_URL"
        echo "sha256=$PKG_SHA256"
        echo "built_at=$(now_utc)"
    } >"$META"
}

# Detect collisions with installed packages (file ownership)
collision_check() {
    [ "$XBUILD_FORCE" = "1" ] && return 0
    [ -d "$XBUILD_DB" ] || return 0

    newmf="$MANIFEST"
    [ -f "$newmf" ] || die "internal: missing new manifest"
    # If nothing installed, skip.
    ls -1 "$XBUILD_DB"/*/manifest.txt >/dev/null 2>&1 || return 0

    for oldmf in "$XBUILD_DB"/*/manifest.txt; do
        [ -f "$oldmf" ] || continue
        oldpkg=$(basename "$(dirname "$oldmf")")
        [ "$oldpkg" = "$PKG_ID" ] && continue
        # comm needs sorted input; manifests are sorted.
        overlap=$(comm -12 "$newmf" "$oldmf" | awk 'NR==1{print;exit}')
        if [ -n "$overlap" ]; then
            die "file collision detected with installed package $oldpkg at path: $overlap (set XBUILD_FORCE=1 to override)"
        fi
    done
}

tar_extract_try() {
    # tar_extract_try <rootdir>
    root=$1
    # Try preserving perms first, fallback without -p if tar doesn't support it.
    if (cd "$root" && tar -xpf -) 2>/dev/null; then
        return 0
    fi
    warn "tar does not support -p or failed; retrying without permission preservation"
    (cd "$root" && tar -xf -) || return 1
}

copy_to_rootfs() {
    is_abs "$XBUILD_ROOTFS" || die "rootfs must be absolute: $XBUILD_ROOTFS"
    is_abs "$XBUILD_PREFIX" || die "prefix must be absolute: $XBUILD_PREFIX"
    [ -d "$DESTDIR" ] || die "missing DESTDIR: $DESTDIR"
    [ -d "$XBUILD_ROOTFS" ] || die "rootfs not found: $XBUILD_ROOTFS"

    if [ "$XBUILD_ROOTFS" = "/" ]; then
        [ "$(id -u 2>/dev/null || echo 1)" -eq 0 ] || warn "installing to / usually requires root"
    fi

    # Verify collisions before writing into rootfs.
    collision_check

    # Copy using tar pipeline to preserve permissions and symlinks when possible.
    (cd "$DESTDIR" && tar -cf - .) | tar_extract_try "$XBUILD_ROOTFS" || die "copy into rootfs failed"
}

register_and_finalize() {
    manifest_write
    copy_to_rootfs
    msg "installed: $PKG_ID -> rootfs=$XBUILD_ROOTFS"
    msg "manifest: $MANIFEST"
    msg "log: $logfile"
}

pkg_installed() {
    [ -d "$XBUILD_DB/$1" ] && [ -f "$XBUILD_DB/$1/meta.txt" ]
}

do_remove_pkgid() {
    pkgid=$1
    db="$XBUILD_DB/$pkgid"
    [ -d "$db" ] || die "not installed: $pkgid"
    mf="$db/manifest.txt"
    meta="$db/meta.txt"
    [ -f "$mf" ] || die "missing manifest: $mf"

    rootfs="$XBUILD_ROOTFS"
    if [ -f "$meta" ]; then
        rec_rootfs=$(awk -F= '$1=="rootfs"{print $2}' "$meta" 2>/dev/null | awk 'NR==1{print;exit}')
        [ -n "$rec_rootfs" ] && [ "$rec_rootfs" != "$rootfs" ] && warn "package recorded rootfs=$rec_rootfs; removing from rootfs=$rootfs"
    fi

    confirm "This will remove files for $pkgid from $rootfs. Continue?" || die "aborted"

    awk '{print length, $0}' "$mf" | sort -rn | cut -d" " -f2- |
    while IFS= read -r rel; do
        [ -n "$rel" ] || continue
        f="$rootfs/$rel"
        if [ -e "$f" ] || [ -L "$f" ]; then
            rm -f -- "$f" 2>/dev/null || rm -f "$f" || die "cannot remove: $f"
        fi
    done

    # Remove empty directories (best-effort), derived from manifest paths.
    # Convert each file path to its parent directories, try deepest first.
    awk -F/ 'NF>1{NF--; OFS="/"; print}' "$mf" | sort -u |
    awk '{print length, $0}' | sort -rn | cut -d" " -f2- |
    while IFS= read -r d; do
        [ -n "$d" ] || continue
        rmdir -- "$rootfs/$d" 2>/dev/null || :
    done

    safe_rm_rf "$db"
    msg "removed: $pkgid"
}

# -------- Commands --------
cmd_fetch() {
    msg "fetch: $PKG_ID"
    if [ -f "$SRCFILE" ]; then
        msg "source already cached: $SRCFILE"
        sha256_check "$SRCFILE" "$PKG_SHA256"
        return 0
    fi
    tmp="$XBUILD_TMPDIR/$PKG_ARCHIVE.part"
    download_file "$PKG_URL" "$tmp" || die "download failed: $PKG_URL"
    sha256_check "$tmp" "$PKG_SHA256"
    mv "$tmp" "$SRCFILE" || die "cannot move into cache: $SRCFILE"
    msg "cached: $SRCFILE"
}

cmd_build() {
    cmd_fetch
    msg "build: $PKG_ID"
    unpack_source
    do_build
    msg "build ok: $PKG_ID"
}

cmd_install() {
    cmd_build
    msg "install (stage + finalize): $PKG_ID"
    do_stage_install
    register_and_finalize
    if [ "$XBUILD_KEEP_BUILD" != "1" ] && [ "$XBUILD_KEEP_BUILD" != "true" ]; then
        safe_rm_rf "$BUILDD" 2>/dev/null || :
        safe_rm_rf "$STAGED/destdir" 2>/dev/null || :
    fi
}

cmd_clean() {
    msg "clean: $PKG_ID"
    safe_rm_rf "$BUILDD" 2>/dev/null || :
    safe_rm_rf "$STAGED" 2>/dev/null || :
    msg "cleaned: $PKG_ID"
}

cmd_list() {
    if [ ! -d "$XBUILD_DB" ]; then
        msg "no db directory: $XBUILD_DB"
        return 0
    fi
    found=0
    for d in "$XBUILD_DB"/*; do
        [ -d "$d" ] || continue
        [ -f "$d/meta.txt" ] || continue
        pkgid=$(basename "$d")
        ver=$(awk -F= '$1=="version"{print $2}' "$d/meta.txt" 2>/dev/null | awk 'NR==1{print;exit}')
        ref=$(awk -F= '$1=="ref"{print $2}' "$d/meta.txt" 2>/dev/null | awk 'NR==1{print;exit}')
        printf '%s\t%s\t%s\n' "$pkgid" "$ver" "$ref"
        found=1
    done
    [ "$found" -eq 1 ] || msg "no packages installed"
}

cmd_info() {
    msg "info: $PKG_ID"
    printf '%s\n' "recipe: $recipe_file"
    printf '%s\n' "ref:    $PKG_REF"
    printf '%s\n' "name:   $PKG_NAME"
    printf '%s\n' "ver:    $PKG_VERSION"
    printf '%s\n' "url:    $PKG_URL"
    printf '%s\n' "sha256: $PKG_SHA256"
    printf '%s\n' "build:  $PKG_BUILD_SYSTEM"
    [ -n "${PKG_DEPENDS:-}" ] && printf '%s\n' "deps:   $PKG_DEPENDS"
    if [ -f "$PKG_DB/meta.txt" ]; then
        printf '\n%s\n' "installed meta:"
        cat "$PKG_DB/meta.txt"
    else
        printf '\n%s\n' "not installed"
    fi
}

# -------- Arg parsing --------
CMD=
PKGARG=
parse_args() {
    [ $# -ge 1 ] || { usage; exit 1; }
    c=$1; shift
    case "$c" in
        fetch|f)   CMD=fetch ;;
        build|b)   CMD=build ;;
        install|i) CMD=install ;;
        remove|r)  CMD=remove ;;
        list|ls)   CMD=list ;;
        info|in)   CMD=info ;;
        clean|cl)  CMD=clean ;;
        help|h|-h|--help) usage; exit 0 ;;
        *) die "unknown command: $c (use: xbuild help)" ;;
    esac

    while [ $# -gt 0 ]; do
        case "$1" in
            -R|--rootfs) shift; [ $# -gt 0 ] || die "missing arg for --rootfs"; XBUILD_ROOTFS=$1 ;;
            -P|--prefix) shift; [ $# -gt 0 ] || die "missing arg for --prefix"; XBUILD_PREFIX=$1 ;;
            -r|--recipes) shift; [ $# -gt 0 ] || die "missing arg for --recipes"; XBUILD_RECIPES=$1 ;;
            -j|--jobs) shift; [ $# -gt 0 ] || die "missing arg for --jobs"; XBUILD_JOBS=$1 ;;
            -k|--keep-build) XBUILD_KEEP_BUILD=1 ;;
            -y|--yes) XBUILD_ASSUME_YES=1 ;;
            -q|--quiet) QUIET=1 ;;
            -v|--verbose) VERBOSE=1 ;;
            --) shift; break ;;
            -*)
                die "unknown option: $1"
                ;;
            *)
                break
                ;;
        esac
        shift
    done

    if [ "$CMD" = "list" ]; then
        return 0
    fi

    [ $# -ge 1 ] || die "missing package argument"
    PKGARG=$1
}

main() {
    parse_args "$@"

    # strict sanity checks that don't require recipe
    if [ "$XBUILD_STRICT" = "1" ]; then
        is_abs "$XBUILD_PREFIX" || die "prefix must be absolute (e.g. /usr): $XBUILD_PREFIX"
        is_abs "$XBUILD_ROOTFS" || die "rootfs must be absolute: $XBUILD_ROOTFS"
    fi

    lock_acquire

    if [ "$CMD" = "list" ]; then
        mkp "$XBUILD_DB"
        cmd_list
        return 0
    fi

    # Special-case remove: allow removing by pkgid even if recipe is missing.
    if [ "$CMD" = "remove" ]; then
        mkp "$XBUILD_DB"
        if pkg_installed "$PKGARG"; then
            do_remove_pkgid "$PKGARG"
            return 0
        fi
        # Otherwise interpret argument as recipe ref/name, load recipe to compute PKG_ID.
        [ -d "$XBUILD_RECIPES" ] || die "recipes dir not found: $XBUILD_RECIPES"
        recipe_file=$(recipe_find "$PKGARG")
        recipe_load "$recipe_file"
        paths_init
        do_remove_pkgid "$PKG_ID"
        return 0
    fi

    [ -d "$XBUILD_RECIPES" ] || die "recipes dir not found: $XBUILD_RECIPES"
    recipe_file=$(recipe_find "$PKGARG")
    recipe_load "$recipe_file"
    paths_init

    case "$CMD" in
        fetch)   cmd_fetch ;;
        build)   cmd_build ;;
        install) cmd_install ;;
        clean)   cmd_clean ;;
        info)    cmd_info ;;
        *) die "internal: unhandled command: $CMD" ;;
    esac
}

main "$@"
