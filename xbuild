#!/bin/sh

set -eu

###############################################################################
# REQUIREMENTS (documented, not enforced perfectly)
# - sh, awk, sed, grep, find, mkdir, rm, rmdir, chmod, cp OR tar
# - tar and/or unzip depending on archive format
# - cksum (POSIX)
# - curl or wget for fetching (recommended)
# - sha256sum OR shasum OR openssl for SHA-256 verification
###############################################################################

XBUILD_VERSION="1.1-stable"

###############################################################################
# Configuration (override via env or config)
###############################################################################

: "${XBUILD_ROOT:=$PWD}"
: "${XBUILD_WORK:=$XBUILD_ROOT/work}"
: "${XBUILD_SYSROOT:=$XBUILD_ROOT/sysroot}"
: "${XBUILD_DB:=$XBUILD_ROOT/db}"
: "${XBUILD_LOCKDIR:=$XBUILD_ROOT/.xbuild.lock}"

: "${XBUILD_DISTFILES:=$XBUILD_ROOT/distfiles}"
: "${XBUILD_RECIPES_DIR:=$XBUILD_ROOT/recipes}"

: "${XBUILD_PROFILE:=host}"          # host | bootstrap | cross
# XBUILD_INSTALL_MODE is set by profile unless explicitly provided.
: "${XBUILD_TARGET_ROOT:=/}"        # used in host mode; must be "/" unless you know what you're doing
: "${XBUILD_ALLOW_HOST_INSTALL:=0}" # must be 1 to install into "/"
: "${XBUILD_JOBS:=1}"

: "${XBUILD_STRIP_SUID:=1}"         # 1 = strip setuid/setgid bits during install
: "${XBUILD_ALLOW_SYMLINKS:=1}"     # 0 = reject archives containing symlinks (very strict)
: "${XBUILD_STRICT_SYSROOT:=1}"     # 1 = set sysroot pkg-config vars; does not sandbox compiler

: "${XBUILD_CONFIG:=}"              # optional config file to source (shell)

umask 022

###############################################################################
# Utilities
###############################################################################

die() { printf '%s\n' "xbuild: $*" >&2; exit 1; }
msg() { printf '%s\n' "==> $*" >&2; }

need() { command -v "$1" >/dev/null 2>&1 || die "missing required tool: $1"; }
mkdirp() { [ -d "$1" ] || mkdir -p "$1"; }

# Reject filenames containing newline (breaks line-based plumbing safely).
reject_newlines_in_tree() {
    root=$1
    # If any path printed by find contains a newline, the output will be ambiguous.
    # We detect this by checking for an embedded newline in each entry (find prints one per line).
    # This will not detect literal newlines perfectly, so we instead reject if a file contains '\n'
    # in its name by using find -print and comparing count; pragmatic: disallow newlines globally.
    if find "$root" -name '*'"$(printf '\n')"*' >/dev/null 2>&1; then
        die "newline in filename detected under: $root (unsupported)"
    fi
}

###############################################################################
# Config loading (explicit)
###############################################################################

load_config() {
    [ -n "$XBUILD_CONFIG" ] || return 0
    [ -f "$XBUILD_CONFIG" ] || die "config not found: $XBUILD_CONFIG"
    # Config is shell code; user is responsible for protecting it.
    # shellcheck disable=SC1090
    . "$XBUILD_CONFIG"
}

###############################################################################
# Profiles (host / bootstrap / cross)
###############################################################################

apply_profile() {
    # Profiles set defaults. Explicit env/config overrides are respected if set.
    # Detect whether variables are explicitly set using the ${VAR+x} idiom.
    install_mode_set=0
    strict_set=0
    sysroot_set=0
    if [ "${XBUILD_INSTALL_MODE+x}" = "x" ]; then install_mode_set=1; fi
    if [ "${XBUILD_STRICT_SYSROOT+x}" = "x" ]; then strict_set=1; fi
    if [ "${XBUILD_SYSROOT+x}" = "x" ]; then sysroot_set=1; fi

    case "$XBUILD_PROFILE" in
        host)
            if [ $install_mode_set -eq 0 ]; then XBUILD_INSTALL_MODE=host; fi
            if [ $strict_set -eq 0 ]; then XBUILD_STRICT_SYSROOT=0; fi
            ;;
        bootstrap)
            if [ $install_mode_set -eq 0 ]; then XBUILD_INSTALL_MODE=sysroot; fi
            if [ $sysroot_set -eq 0 ]; then XBUILD_SYSROOT="$XBUILD_ROOT/bootstrap-sysroot"; fi
            if [ $strict_set -eq 0 ]; then XBUILD_STRICT_SYSROOT=1; fi
            ;;
        cross)
            if [ $install_mode_set -eq 0 ]; then XBUILD_INSTALL_MODE=sysroot; fi
            if [ $strict_set -eq 0 ]; then XBUILD_STRICT_SYSROOT=1; fi
            ;;
        *)
            die "invalid XBUILD_PROFILE: $XBUILD_PROFILE (expected host|bootstrap|cross)"
            ;;
    esac
}



###############################################################################
# Locking (robust enough: PID + timestamp + host)
###############################################################################

lock() {
    mkdirp "$XBUILD_LOCKDIR"
    if [ -f "$XBUILD_LOCKDIR/meta" ]; then
        read -r pid ts host <"$XBUILD_LOCKDIR/meta" || true
        if [ -n "${pid:-}" ] && kill -0 "$pid" 2>/dev/null; then
            die "another xbuild instance is running (pid $pid on ${host:-unknown})"
        fi
    fi
    printf '%s %s %s\n' "$$" "$(date +%s 2>/dev/null || echo 0)" "$(hostname 2>/dev/null || echo unknown)" >"$XBUILD_LOCKDIR/meta"
}

unlock() { rm -rf "$XBUILD_LOCKDIR"; }
trap unlock EXIT INT TERM

###############################################################################
# Target root resolution
###############################################################################

target_root() {
    case "$XBUILD_INSTALL_MODE" in
        host)
            [ "$XBUILD_TARGET_ROOT" = "/" ] || die "in host mode, XBUILD_TARGET_ROOT must be '/' (got '$XBUILD_TARGET_ROOT')"
            [ "$XBUILD_ALLOW_HOST_INSTALL" = "1" ] || die "refusing to install into '/'. Set XBUILD_ALLOW_HOST_INSTALL=1 to proceed."
            printf '%s\n' "/"
            ;;
        sysroot)
            mkdirp "$XBUILD_SYSROOT"
            printf '%s\n' "$XBUILD_SYSROOT"
            ;;
        *)
            die "invalid XBUILD_INSTALL_MODE: $XBUILD_INSTALL_MODE (expected host|sysroot)"
            ;;
    esac
}

###############################################################################
# Distfiles fetch + cache + sha256
###############################################################################

is_url() {
    case "$1" in
        http://*|https://*|ftp://*) return 0 ;;
        *) return 1 ;;
    esac
}

url_basename() {
    # Strip query string if present.
    u=$1
    b=${u##*/}
    b=${b%%\?*}
    [ -n "$b" ] || die "cannot derive distfile name from URL: $u"
    printf '%s\n' "$b"
}

sha256_tool() {
    if command -v sha256sum >/dev/null 2>&1; then
        printf '%s\n' "sha256sum"
        return 0
    fi
    if command -v shasum >/dev/null 2>&1; then
        # perl shasum typically supports -a 256
        printf '%s\n' "shasum"
        return 0
    fi
    if command -v openssl >/dev/null 2>&1; then
        printf '%s\n' "openssl"
        return 0
    fi
    return 1
}

sha256_file() {
    f=$1
    tool=$(sha256_tool) || die "no sha256 tool found (need sha256sum, shasum, or openssl)"
    case "$tool" in
        sha256sum) sha256sum "$f" | awk '{print $1}' ;;
        shasum) shasum -a 256 "$f" | awk '{print $1}' ;;
        openssl) openssl dgst -sha256 "$f" | awk '{print $2}' ;;
        *) die "unexpected sha256 tool: $tool" ;;
    esac
}

cmd_hash_file() {
    [ $# -eq 1 ] || die "usage: xbuild hash <file>"
    f=$1
    [ -f "$f" ] || die "file not found: $f"
    sha256_file "$f"
}

cmd_hash_recipe() {
    [ $# -eq 1 ] || die "usage: xbuild hash-recipe <recipe>"
    recipe=$1
    [ -f "$recipe" ] || die "recipe not found: $recipe"
    # shellcheck disable=SC1090
    . "$recipe"
    : "${PKGNAME:?recipe missing PKGNAME}"
    : "${VERSION:?recipe missing VERSION}"
    dist=$(fetch_distfile 2>/dev/null || true)
    if [ -n "${dist:-}" ] && [ -f "$dist" ]; then
        sha256_file "$dist"
        return 0
    fi
    # If recipe is missing SOURCE_SHA256, fall back to gen-sha behavior.
    cmd_gen_sha "$recipe" | awk 'NR==1{print; exit}'
}


verify_sha256() {
    f=$1 want=$2
    [ -n "$want" ] || die "missing SOURCE_SHA256 for $f"
    got=$(sha256_file "$f")
    [ "$got" = "$want" ] || die "sha256 mismatch for $(basename "$f"): expected $want, got $got"
}
cmd_gen_sha() {
    # usage: xbuild gen-sha <recipe|pkg|url>
    [ $# -eq 1 ] || die "usage: xbuild gen-sha <recipe|pkg|url>"
    arg=$1

    mkdirp "$XBUILD_DISTFILES"

    if is_url "$arg"; then
        url="$arg"
        fname=$(url_basename "$url")
        dest="$XBUILD_DISTFILES/$fname"
        if [ ! -f "$dest" ]; then
            msg "fetching distfile (no hash required): $url"
            fetch_url_to "$url" "$dest"
        fi
        sha=$(sha256_file "$dest")
        printf '%s\n' "$sha"
        printf '%s\n' "SOURCE_URL=\"$url\""
        printf '%s\n' "SOURCE_SHA256=\"$sha\""
        return 0
    fi

    recipe=$(resolve_recipe "$arg")
    # shellcheck disable=SC1090
    . "$recipe"
    : "${PKGNAME:?recipe missing PKGNAME}"
    : "${VERSION:?recipe missing VERSION}"

    # Resolve URL/path without requiring SOURCE_SHA256.
    if [ -n "${SOURCE_URL:-}" ]; then
        url=$SOURCE_URL
    elif [ -n "${SOURCE:-}" ] && is_url "$SOURCE"; then
        url=$SOURCE
    else
        url=""
    fi

    if [ -n "$url" ]; then
        fname=${SOURCE_FILE:-$(url_basename "$url")}
        dest="$XBUILD_DISTFILES/$fname"
        if [ ! -f "$dest" ]; then
            msg "fetching distfile (no hash required): $url"
            fetch_url_to "$url" "$dest"
        fi
        sha=$(sha256_file "$dest")
        printf '%s\n' "$sha"
        printf '%s\n' "SOURCE_URL=\"$url\""
        printf '%s\n' "SOURCE_SHA256=\"$sha\""
        return 0
    fi

    : "${SOURCE:?recipe missing SOURCE or SOURCE_URL}"
    [ -f "$SOURCE" ] || die "SOURCE not found: $SOURCE"
    sha=$(sha256_file "$SOURCE")
    printf '%s\n' "$sha"
    printf '%s\n' "SOURCE=\"$SOURCE\""
    printf '%s\n' "SOURCE_SHA256=\"$sha\""
}


fetch_url_to() {
    url=$1 out=$2
    tmp="$out.part.$$"
    rm -f "$tmp"

    if command -v curl >/dev/null 2>&1; then
        curl -L --fail --retry 3 --retry-delay 1 -o "$tmp" "$url" || {
            rm -f "$tmp"
            die "fetch failed (curl): $url"
        }
    elif command -v wget >/dev/null 2>&1; then
        wget -O "$tmp" "$url" || {
            rm -f "$tmp"
            die "fetch failed (wget): $url"
        }
    else
        die "no fetch tool found (need curl or wget)"
    fi

    mv "$tmp" "$out"
}

fetch_distfile() {
    # Inputs: SOURCE (local path) OR SOURCE_URL (remote), and optional SOURCE_FILE name.
    # Outputs: echoes the resolved local distfile path.
    : "${PKGNAME:?recipe missing PKGNAME}"
    : "${VERSION:?recipe missing VERSION}"

    mkdirp "$XBUILD_DISTFILES"

    # Determine URL/path
    if [ -n "${SOURCE_URL:-}" ]; then
        url=$SOURCE_URL
    elif [ -n "${SOURCE:-}" ] && is_url "$SOURCE"; then
        url=$SOURCE
    else
        url=""
    fi

    if [ -n "$url" ]; then
        fname=${SOURCE_FILE:-$(url_basename "$url")}
        dest="$XBUILD_DISTFILES/$fname"

        if [ -f "$dest" ]; then
            # Verify cached file before use.
            if [ -n "${SOURCE_SHA256:-}" ]; then
                verify_sha256 "$dest" "$SOURCE_SHA256"
            fi
            printf '%s\n' "$dest"
            return 0
        fi

        msg "fetching distfile: $url"
        fetch_url_to "$url" "$dest"

        if [ -n "${SOURCE_SHA256:-}" ]; then
            verify_sha256 "$dest" "$SOURCE_SHA256"
        else
            die "SOURCE_SHA256 is required for remote sources (PKGNAME=$PKGNAME)"
        fi

        printf '%s\n' "$dest"
        return 0
    fi

    # Local source path case
    : "${SOURCE:?recipe missing SOURCE or SOURCE_URL}"
    [ -f "$SOURCE" ] || die "SOURCE not found: $SOURCE"
    if [ -n "${SOURCE_SHA256:-}" ]; then
        verify_sha256 "$SOURCE" "$SOURCE_SHA256"
    fi
    printf '%s\n' "$SOURCE"
}

cmd_fetch_recipe() {
    recipe=$1
    [ -f "$recipe" ] || die "recipe not found: $recipe"
    # shellcheck disable=SC1090
    . "$recipe"

    : "${PKGNAME:?recipe missing PKGNAME}"
    : "${VERSION:?recipe missing VERSION}"

    # Resolve/fetch distfile and verify checksum.
    dist=$(fetch_distfile)
    msg "distfile ready: $dist"
}

cmd_distfiles_ls() {
    mkdirp "$XBUILD_DISTFILES"
    ls -l "$XBUILD_DISTFILES"
}

cmd_distfiles_prune_partials() {
    mkdirp "$XBUILD_DISTFILES"
    # Remove orphaned partial downloads (*.part.*)
    find "$XBUILD_DISTFILES" -maxdepth 1 -type f -name '*.part.*' -print | while IFS= read -r f; do
        rm -f "$f" 2>/dev/null || true
    done
    msg "pruned partial downloads in: $XBUILD_DISTFILES"
}

###############################################################################
# Archive handling (hardened)
###############################################################################

validate_paths_stream() {
    # Reject absolute paths and any '..' component.
    awk '
        BEGIN{bad=0}
        {
            if ($0 ~ /^\/+/) bad=1
            if ($0 ~ /(^|\/)\.\.(\/|$)/) bad=1
        }
        END{exit bad}
    '
}

extract_postcheck_symlinks() {
    out=$1
    [ "$XBUILD_ALLOW_SYMLINKS" = "1" ] || return 0
    # Verify all symlinks are relative and non-escaping.
    # readlink is common; if unavailable, skip with warning (still safe for typical sources).
    if command -v readlink >/dev/null 2>&1; then
        find "$out" -type l 2>/dev/null | while IFS= read -r lnk; do
            tgt=$(readlink "$lnk" || true)
            [ -n "$tgt" ] || continue
            case "$tgt" in
                /*) die "unsafe symlink (absolute target) in extracted tree: $lnk -> $tgt" ;;
            esac
            # reject any .. component in target
            printf '%s\n' "$tgt" | validate_paths_stream || die "unsafe symlink (escaping '..') in extracted tree: $lnk -> $tgt"
        done
    fi
}

extract_tar() {
    arc=$1 out=$2
    mkdirp "$out"
    tar -tf "$arc" | validate_paths_stream || die "unsafe paths in tar archive: $arc"

    if [ "$XBUILD_ALLOW_SYMLINKS" != "1" ]; then
        # reject symlinks and hardlinks based on tar listing
        tar -tvf "$arc" | awk '$1 ~ /^l/ {exit 1} $1 ~ /^h/ {exit 1} END{exit 0}' \
            || die "archive contains symlinks/hardlinks but XBUILD_ALLOW_SYMLINKS=0: $arc"
    fi

    tar --no-same-owner --no-same-permissions -xf "$arc" -C "$out"
    extract_postcheck_symlinks "$out"
}

extract_zip() {
    arc=$1 out=$2
    mkdirp "$out"
    need unzip
    unzip -Z1 "$arc" | validate_paths_stream || die "unsafe paths in zip archive: $arc"
    unzip -oq "$arc" -d "$out"
    extract_postcheck_symlinks "$out"
}

extract() {
    arc=$1 out=$2
    case "$arc" in
        *.tar|*.tar.gz|*.tgz|*.tar.bz2|*.tar.xz|*.tar.zst)
            need tar
            extract_tar "$arc" "$out"
            ;;
        *.zip)
            extract_zip "$arc" "$out"
            ;;
        *)
            die "unknown archive format: $arc"
            ;;
    esac
    reject_newlines_in_tree "$out"
}

###############################################################################
# Ownership DB (refcounted; safe for arbitrary paths)
#
# Storage layout:
#   db/pkgs/<pkg>/files   (absolute paths installed by pkg)
#   db/owners/<key>       (first line: PATH\t<abs-path>; next lines: PKG\t<pkg>)
###############################################################################

pkg_db_dir() { printf '%s\n' "$XBUILD_DB/pkgs/$1"; }
owners_dir() { printf '%s\n' "$XBUILD_DB/owners"; }

owner_key() {
    # cksum is POSIX; returns "<crc> <bytes>".
    # We include bytes to reduce collision risk in practice.
    printf '%s' "$1" | cksum | awk '{print $1 "-" $2}'
}

owner_rec_path() {
    path=$1
    key=$(owner_key "$path")
    printf '%s\n' "$(owners_dir)/$key"
}

owner_rec_ensure_matches_path() {
    rec=$1 path=$2
    if [ -f "$rec" ]; then
        stored=$(awk -F '\t' '$1=="PATH"{print $2; exit}' "$rec" 2>/dev/null || true)
        [ "$stored" = "$path" ] || die "owner DB key collision detected for path: $path"
    else
        mkdirp "$(owners_dir)"
        printf 'PATH\t%s\n' "$path" >"$rec"
    fi
}

owner_has_pkg() {
    rec=$1 pkg=$2
    awk -F '\t' -v p="$pkg" '$1=="PKG" && $2==p {found=1} END{exit (found?0:1)}' "$rec" 2>/dev/null
}

owner_add_pkg() {
    path=$1 pkg=$2
    rec=$(owner_rec_path "$path")
    owner_rec_ensure_matches_path "$rec" "$path"
    if owner_has_pkg "$rec" "$pkg"; then
        return 0
    fi
    printf 'PKG\t%s\n' "$pkg" >>"$rec"
}

owner_remove_pkg() {
    path=$1 pkg=$2
    rec=$(owner_rec_path "$path")
    [ -f "$rec" ] || return 0
    owner_rec_ensure_matches_path "$rec" "$path"
    # Keep PATH line + all other PKG lines except this pkg.
    awk -F '\t' -v p="$pkg" '
        $1=="PATH" {print; next}
        $1=="PKG" && $2==p {next}
        {print}
    ' "$rec" >"$rec.tmp"
    mv "$rec.tmp" "$rec"
    # If no PKG lines remain, delete record.
    if ! awk -F '\t' '$1=="PKG"{exit 0} END{exit 1}' "$rec"; then
        rm -f "$rec"
        return 1  # indicates: now unowned
    fi
    return 0
}

pkg_write_meta() {
    pkg=$1 ver=$2 rec=$3
    mkdirp "$(pkg_db_dir "$pkg")"
    printf 'PKGNAME=%s\nVERSION=%s\nRECIPE=%s\nINSTALLED_AT=%s\n' "$pkg" "$ver" "$rec" "$(date +%s 2>/dev/null || echo 0)" >"$(pkg_db_dir "$pkg")/meta"
}

pkg_init() {
    pkg=$1
    mkdirp "$(pkg_db_dir "$pkg")"
    : >"$(pkg_db_dir "$pkg")/files"
}

pkg_is_installed() { [ -d "$(pkg_db_dir "$1")" ]; }

pkg_record_file() {
    pkg=$1 path=$2
    printf '%s\n' "$path" >>"$(pkg_db_dir "$pkg")/files"
}

###############################################################################
# Install / Merge (collision safe)
###############################################################################

cp_supports_a() {
    # Some minimal cp implementations don't support -a. Probe once.
    if cp -a /dev/null /dev/null 2>/dev/null; then
        return 0
    fi
    return 1
}

install_entry() {
    src=$1 dst=$2

    # Ensure directory exists.
    mkdirp "$(dirname "$dst")"

    # Install symlink or regular file. We ignore device files and special nodes.
    if [ -L "$src" ]; then
        # Recreate symlink atomically-ish.
        tgt=$(readlink "$src" 2>/dev/null || true)
        [ -n "$tgt" ] || die "failed to read symlink: $src"
        rm -f "$dst"
        ln -s "$tgt" "$dst"
    elif [ -f "$src" ]; then
        if cp_supports_a; then
            cp -a "$src" "$dst"
        else
            # Fallback: tar pipeline for a single file (no -p; no owner).
            ( cd "$(dirname "$src")" && tar -cf - "$(basename "$src")" ) | ( cd "$(dirname "$dst")" && tar -xf - )
        fi
        if [ "$XBUILD_STRIP_SUID" = "1" ]; then
            chmod ug-s "$dst" 2>/dev/null || true
        fi
    else
        # Directories handled elsewhere; other types are ignored for safety.
        return 0
    fi
}

merge_tree() {
    pkg=$1 staged=$2 root=$3

    [ -d "$staged" ] || die "staged directory not found: $staged"
    reject_newlines_in_tree "$staged"

    # Install directories first (so later installs don't fail).
    find "$staged" -type d 2>/dev/null | while IFS= read -r d; do
        rel=${d#"$staged"/}
        [ "$rel" != "$d" ] || rel=""  # root itself
        [ -n "$rel" ] || continue
        mkdirp "$root/$rel"
    done

    # Install files and symlinks.
    find "$staged" \( -type f -o -type l \) 2>/dev/null | while IFS= read -r src; do
        rel=${src#"$staged"/}
        dst=$root/$rel

        # Collision policy: if dst exists and is owned by another package -> abort.
        if [ -e "$dst" ] || [ -L "$dst" ]; then
            rec=$(owner_rec_path "$dst")
            if [ -f "$rec" ]; then
                # If owned by someone else, collision.
                if ! owner_has_pkg "$rec" "$pkg"; then
                    die "file collision: $dst already owned by another package"
                fi
                # Owned by same package: reinstall is allowed.
            else
                die "file collision: $dst already exists but is not tracked (refusing overwrite)"
            fi
        fi

        install_entry "$src" "$dst"
        owner_add_pkg "$dst" "$pkg"
        pkg_record_file "$pkg" "$dst"
    done
}

###############################################################################
# Remove (safe; shared files kept)
###############################################################################

remove_pkg() {
    pkg=$1
    pkg_is_installed "$pkg" || die "package not installed: $pkg"

    # Remove owned files if they become unowned.
    files="$(pkg_db_dir "$pkg")/files"
    [ -f "$files" ] || die "corrupt DB for $pkg (missing files list)"

    # Track directories for cleanup (best-effort).
    tmpdirs="$XBUILD_WORK/.rm-dirs.$$"
    : >"$tmpdirs"

    while IFS= read -r path; do
        [ -n "$path" ] || continue

        # Remove ownership; if unowned, delete file.
        if owner_remove_pkg "$path" "$pkg"; then
            : # still owned by someone else; keep file
        else
            # unowned now; delete file/symlink
            rm -f "$path" 2>/dev/null || true
            # queue dir cleanup
            printf '%s\n' "$(dirname "$path")" >>"$tmpdirs"
        fi
    done <"$files"

    # Cleanup empty dirs, deepest first.
    # We sort by length desc; safe enough for typical trees.
    awk '{print length($0) "\t" $0}' "$tmpdirs" | sort -rn | awk -F '\t' '{print $2}' | \
    while IFS= read -r d; do
        [ -n "$d" ] || continue
        # Never attempt to remove root directory.
        [ "$d" = "/" ] && continue
        rmdir "$d" 2>/dev/null || true
    done

    rm -f "$tmpdirs"
    rm -rf "$(pkg_db_dir "$pkg")"
    msg "removed: $pkg"
}

###############################################################################
# Dependency graph (simple, no version solving; cycle detection)
#
# Recipe metadata:
#   DEPENDS="pkg1 pkg2"            # package names resolved via XBUILD_RECIPES_DIR/<pkg>.recipe
#   DEPENDS_RECIPES="path1 path2"  # explicit recipe paths (optional)
###############################################################################

is_recipe_path() {
    case "$1" in
        */*|*.recipe) return 0 ;;
        *) return 1 ;;
    esac
}

resolve_recipe() {
    tok=$1

    # Direct path
    if is_recipe_path "$tok"; then
        [ -f "$tok" ] || die "dependency recipe not found: $tok"
        printf '%s\n' "$tok"
        return 0
    fi

    # category/program form (e.g., "base/zlib")
    case "$tok" in
        */*)
            cat=${tok%%/*}
            prog=${tok#*/}
            p1="$XBUILD_RECIPES_DIR/$cat/$prog/recipe"
            p2="$XBUILD_RECIPES_DIR/$cat/$prog/$prog.recipe"
            p3="$XBUILD_RECIPES_DIR/$cat/$prog.recipe"
            if [ -f "$p1" ]; then printf '%s\n' "$p1"; return 0; fi
            if [ -f "$p2" ]; then printf '%s\n' "$p2"; return 0; fi
            if [ -f "$p3" ]; then printf '%s\n' "$p3"; return 0; fi
            die "recipe for '$tok' not found (tried: $p1, $p2, $p3)"
            ;;
    esac

    # simple package name
    p="$XBUILD_RECIPES_DIR/$tok.recipe"
    if [ -f "$p" ]; then
        printf '%s\n' "$p"
        return 0
    fi

    # fallback: search unique match in category/program layout: recipes/*/<tok>/recipe
    found=""
    for cand in "$XBUILD_RECIPES_DIR"/*/"$tok"/recipe; do
        if [ -f "$cand" ]; then
            if [ -n "$found" ] && [ "$found" != "$cand" ]; then
                die "ambiguous package '$tok' (multiple recipes found). Use category/program."
            fi
            found="$cand"
        fi
    done
    if [ -n "$found" ]; then
        printf '%s\n' "$found"
        return 0
    fi

    die "dependency recipe for '$tok' not found under: $XBUILD_RECIPES_DIR"
}


# Read recipe and print: "<pkgname>\t<recipepath>"
recipe_id() {
    r=$1
    [ -f "$r" ] || die "recipe not found: $r"
    # Source in a subshell to avoid leaking vars into caller.
    (
        # shellcheck disable=SC1090
        . "$r"
        : "${PKGNAME:?recipe missing PKGNAME}"
        printf '%s\t%s\n' "$PKGNAME" "$r"
    )
}

# List dependency recipe paths (one per line) for a given recipe path.
recipe_deps() {
    r=$1
    (
        # shellcheck disable=SC1090
        . "$r"
        # DEPENDS_RECIPES may contain recipe paths; DEPENDS contains package names.
        for t in ${DEPENDS_RECIPES:-}; do
            resolve_recipe "$t"
        done
        for p in ${DEPENDS:-}; do
            resolve_recipe "$p"
        done
    )
}

# Topological sort with cycle detection (DFS).
# Output: recipe paths in build order (deps first).
# Topological sort with cycle detection (DFS).
# Output: recipe paths in build order (deps first).
# Accepts 1..N root recipe paths.
toposort_recipes() {
    state="$XBUILD_WORK/.depstate.$$"
    mkdirp "$state/tmp" "$state/perm" "$state/map"
    order="$state/order"
    : >"$order"

    visit() {
        rpath=$1
        id="$(recipe_id "$rpath")"
        pkg="${id%%	*}"

        if [ -f "$state/perm/$pkg" ]; then
            return 0
        fi
        if [ -f "$state/tmp/$pkg" ]; then
            die "dependency cycle detected at package: $pkg (recipe $rpath)"
        fi

        : >"$state/tmp/$pkg"
        printf '%s\n' "$rpath" >"$state/map/$pkg"

        depsfile="$state/deps.$pkg.$$"
        : >"$depsfile"
        recipe_deps "$rpath" >"$depsfile"

        while IFS= read -r dep; do
            [ -n "$dep" ] || continue
            visit "$dep"
        done <"$depsfile"

        rm -f "$depsfile"
        rm -f "$state/tmp/$pkg"
        : >"$state/perm/$pkg"
        printf '%s\n' "$rpath" >>"$order"
    }

    # Visit each root in order
    for r in "$@"; do
        visit "$r"
    done

    cat "$order"
}



###############################################################################
# Recipe 'files/' overlay support
# If <recipe-dir>/files exists, its contents are copied into the staging root
# after install() runs. Paths are relative to filesystem root.
###############################################################################

overlay_files_dir() {
    filesdir=$1
    staged=$2
    [ -d "$filesdir" ] || return 0
    reject_newlines_in_tree "$filesdir"

    # Copy preserving symlinks. Prefer tar pipeline to avoid cp -a portability issues.
    ( cd "$filesdir" && tar -cf - . ) | ( cd "$staged" && tar -xf - )
}


###############################################################################
# Build orchestration
###############################################################################

# Recipe contract:
#   Required vars: PKGNAME, VERSION, SOURCE
#   Required functions: build(), install()
#   Optional vars: WORKDIR_SUBDIR (if archive expands into a single subdir)
#
# SOURCE is a local path to a distfile (fetch/checksum will be added later).
#
# build() should compile in $builddir using sources in $srcdir (or $sourcedir).
# install() must install into $DESTDIR (already set) with a prefix relative to / (standard).
#
# Example install: make DESTDIR="$DESTDIR" install

build_pkg() {
    recipe=$1
    [ -f "$recipe" ] || die "recipe not found: $recipe"
    # shellcheck disable=SC1090
    . "$recipe"

    : "${PKGNAME:?recipe missing PKGNAME}"
    : "${VERSION:?recipe missing VERSION}"
    : "${SOURCE:?recipe missing SOURCE}"

    mkdirp "$XBUILD_WORK"
    work="$XBUILD_WORK/$PKGNAME-$VERSION"
    srcdir="$work/src"
    builddir="$work/build"
    staged="$work/stage"

    rm -rf "$work"
    mkdirp "$srcdir" "$builddir" "$staged"

    msg "preparing distfile: $PKGNAME-$VERSION"
    distfile=$(fetch_distfile)

    msg "extracting: $PKGNAME-$VERSION"
    extract "$distfile" "$srcdir"

    # Determine the effective source directory.
    sourcedir="$srcdir"
    if [ -n "${WORKDIR_SUBDIR:-}" ] && [ -d "$srcdir/$WORKDIR_SUBDIR" ]; then
        sourcedir="$srcdir/$WORKDIR_SUBDIR"
    else
        # Common case: tarball creates exactly one top-level directory.
        topcount=$(find "$srcdir" -mindepth 1 -maxdepth 1 -type d 2>/dev/null | awk 'END{print NR}')
        if [ "$topcount" = "1" ]; then
            onlydir=$(find "$srcdir" -mindepth 1 -maxdepth 1 -type d 2>/dev/null | head -n 1)
            [ -n "$onlydir" ] && sourcedir="$onlydir"
        fi
    fi

    XBUILD_RECIPE_DIR=$(dirname "$recipe")

    msg "building: $PKGNAME-$VERSION"
    (
        cd "$builddir"

        export DESTDIR="$staged"
        export MAKEFLAGS="-j$XBUILD_JOBS"

        if [ "$XBUILD_INSTALL_MODE" = "sysroot" ] && [ "$XBUILD_STRICT_SYSROOT" = "1" ]; then
            export PKG_CONFIG_SYSROOT_DIR="$XBUILD_SYSROOT"
            # Prefer sysroot pkg-config dirs; users can extend as needed.
            export PKG_CONFIG_LIBDIR="$XBUILD_SYSROOT/lib/pkgconfig:$XBUILD_SYSROOT/usr/lib/pkgconfig:$XBUILD_SYSROOT/share/pkgconfig:$XBUILD_SYSROOT/usr/share/pkgconfig"
        fi

        # Provide standard pointers for recipes.
        export XBUILD_SRCDIR="$sourcedir"
        export XBUILD_BUILDDIR="$builddir"

        command -v build >/dev/null 2>&1 || die "recipe missing build() function"
        command -v install >/dev/null 2>&1 || die "recipe missing install() function"

        build
        install

        # Overlay static files from recipe directory (if present)
        overlay_files_dir "$XBUILD_RECIPE_DIR/files" "$staged"
    )

    root="$(target_root)"
    msg "installing into: $root"
    mkdirp "$XBUILD_DB"
    pkg_init "$PKGNAME"
    pkg_write_meta "$PKGNAME" "$VERSION" "$recipe"
    merge_tree "$PKGNAME" "$staged" "$root"
    msg "installed: $PKGNAME"
}

###############################################################################
# Status / diagnostics
###############################################################################

cmd_status() {
    # usage: xbuild status [--verbose]
    verbose=0
    if [ "${1:-}" = "--verbose" ]; then
        verbose=1
    fi

    mkdirp "$XBUILD_DB"
    pkgs_dir="$XBUILD_DB/pkgs"
    owners_dir_path="$(owners_dir)"

    printf '%s\n' "xbuild $XBUILD_VERSION"
    printf '%s\n' "DB: $XBUILD_DB"
    printf '%s\n' "Distfiles: ${XBUILD_DISTFILES:-}"
    printf '%s\n' ""

    if [ ! -d "$pkgs_dir" ]; then
        printf '%s\n' "Installed packages: (none)"
    else
        printf '%s\n' "Installed packages:"
        for d in "$pkgs_dir"/*; do
            [ -d "$d" ] || continue
            pkg=$(basename "$d")
            meta="$d/meta"
            if [ -f "$meta" ]; then
                ver=$(awk -F= '$1=="VERSION"{print $2}' "$meta" 2>/dev/null || true)
                printf '  - %s %s\n' "$pkg" "${ver:-}"
            else
                printf '  - %s\n' "$pkg"
            fi
        done
    fi

    printf '%s\n' ""
    printf '%s\n' "Owners summary:"
    shared_count=0
    orphan_count=0
    inconsist_count=0

    if [ -d "$owners_dir_path" ]; then
        for rec in "$owners_dir_path"/*; do
            [ -f "$rec" ] || continue
            path=$(awk -F '\t' '$1=="PATH"{print $2; exit}' "$rec" 2>/dev/null || true)
            [ -n "$path" ] || continue

            # count owners
            n=$(awk -F '\t' '$1=="PKG"{c++} END{print c+0}' "$rec" 2>/dev/null)
            if [ "$n" -gt 1 ]; then
                shared_count=$((shared_count+1))
                if [ $verbose -eq 1 ]; then
                    printf '  SHARED: %s\n' "$path"
                fi
            fi

            # orphaned file
            if [ ! -e "$path" ] && [ ! -L "$path" ]; then
                orphan_count=$((orphan_count+1))
                if [ $verbose -eq 1 ]; then
                    printf '  ORPHAN FILE MISSING: %s\n' "$path"
                fi
            fi

            # owner refers to non-installed package
            awk -F '\t' -v db="$pkgs_dir" '
                $1=="PKG"{
                    cmd="[ -d \"" db "/" $2 "\" ]"
                    if (system(cmd)!=0) exit 42
                }
                END{exit 0}
            ' "$rec" 2>/dev/null || {
                inconsist_count=$((inconsist_count+1))
                if [ $verbose -eq 1 ]; then
                    printf '  INCONSISTENT OWNER RECORD: %s\n' "$path"
                fi
            }
        done
    fi

    printf '  shared paths: %s\n' "$shared_count"
    printf '  missing files: %s\n' "$orphan_count"
    printf '  inconsistent records: %s\n' "$inconsist_count"

    printf '%s\n' ""
    printf '%s\n' "Collision checks:"
    # Check pkg files lists vs owner DB
    if [ -d "$pkgs_dir" ]; then
        for d in "$pkgs_dir"/*; do
            [ -d "$d" ] || continue
            pkg=$(basename "$d")
            files="$d/files"
            [ -f "$files" ] || continue
            while IFS= read -r path; do
                [ -n "$path" ] || continue
                rec="$(owner_rec_path "$path")"
                if [ ! -f "$rec" ]; then
                    printf '  UNTRACKED-IN-OWNERS: %s (from %s)\n' "$path" "$pkg"
                    continue
                fi
                if ! owner_has_pkg "$rec" "$pkg"; then
                    printf '  OWNER-MISMATCH: %s (expected owner %s)\n' "$path" "$pkg"
                fi
            done <"$files"
        done
    fi
}


###############################################################################
# CLI
###############################################################################

usage() {
    cat >&2 <<EOF
xbuild $XBUILD_VERSION
Usage:
  xbuild fetch <recipe|pkg>       # download + verify distfile (no build)
  xbuild hash <file>              # print sha256 of a file
  xbuild hash-recipe <recipe|pkg> # fetch (if needed) and print sha256 of distfile
  xbuild gen-sha <recipe|pkg|url> # fetch (no hash required) and print sha + recipe lines
  xbuild build <recipe|pkg>       # build target + deps (cycle-checked), install
  xbuild remove <pkg>
  xbuild status [--verbose]    # show installed + owners + collision diagnostics

  xbuild distfiles ls             # list cached distfiles
  xbuild distfiles prune          # remove partial downloads

Profiles:
  XBUILD_PROFILE=host|bootstrap|cross (default: host)

Modes:
  XBUILD_INSTALL_MODE=host|sysroot (default: host)

Host install safety:
  To install into '/', you MUST set:
    XBUILD_ALLOW_HOST_INSTALL=1

Sysroot:
  XBUILD_INSTALL_MODE=sysroot XBUILD_SYSROOT=/path/to/sysroot

EOF
    exit 2
}

main() {
    need awk; need sed; need grep; need find; need mkdir; need rm; need rmdir; need chmod; need cksum; need head; need sort; need ln; need tar
    load_config
    apply_profile
    lock

    cmd=${1:-}
    case "$cmd" in
        fetch)  [ $# -eq 2 ] || usage; cmd_fetch_recipe "$(resolve_recipe "$2")" ;;
        hash)  [ $# -eq 2 ] || usage; cmd_hash_file "$2" ;;
        hash-recipe) [ $# -eq 2 ] || usage; cmd_hash_recipe "$(resolve_recipe "$2")" ;;
        gen-sha) [ $# -eq 2 ] || usage; cmd_gen_sha "$2" ;;
        build)
            [ $# -ge 2 ] || usage
            shift
            roots=""
            for t in "$@"; do
                roots="$roots $(resolve_recipe "$t")"
            done
            # shellcheck disable=SC2086
            toposort_recipes $roots | while IFS= read -r r; do
                [ -n "$r" ] || continue
                id="$(recipe_id "$r")"
                pkg="${id%%	*}"
                if pkg_is_installed "$pkg"; then
                    msg "skipping installed: $pkg"
                else
                    build_pkg "$r"
                fi
            done
            ;;

        remove) [ $# -eq 2 ] || usage; remove_pkg "$2" ;;
        status) [ $# -le 2 ] || usage; cmd_status "${2:-}" ;;
        distfiles)
            sub=${2:-}
            case "$sub" in
                ls)    [ $# -eq 2 ] || usage; cmd_distfiles_ls ;;
                prune) [ $# -eq 2 ] || usage; cmd_distfiles_prune_partials ;;
                *) die "unknown distfiles subcommand: ${sub:-} (expected ls|prune)" ;;
            esac
            ;;
        ""|-h|--help|help) usage ;;
        *) die "unknown command: $cmd" ;;
    esac
}

main "$@"
